/*
 * Copyright 2020 Guardtime, Inc.
 *
 * This file is part of the Guardtime client SDK.
 *
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES, CONDITIONS, OR OTHER LICENSES OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 * "Guardtime" and "KSI" are trademarks or registered trademarks of
 * Guardtime, Inc., and no license to trademarks is granted; Guardtime
 * reserves and retains all trademark rights.
 */

package treebuilder

import (
	stderr "errors"
	"path/filepath"
	"testing"

	"github.com/vincentracine/goksi/errors"
	"github.com/vincentracine/goksi/hash"
	"github.com/vincentracine/goksi/log"
	"github.com/vincentracine/goksi/pdu"
	"github.com/vincentracine/goksi/test"
	"github.com/vincentracine/goksi/test/utils"
	"github.com/vincentracine/goksi/test/utils/mock"
	"github.com/vincentracine/goksi/treebuilder/listener"
)

var (
	testRoot     = filepath.Join("..", "test")
	testLogDir   = filepath.Join(testRoot, "out")
	testConfFile = filepath.Join(testRoot, "systest.conf.json")
)

func TestUnitTreeBuilder(t *testing.T) {
	logger, defFunc, err := test.InitLogger(t, testLogDir, log.DEBUG, t.Name())
	if err != nil {
		t.Fatal("Failed to initialize logger: ", err)
	}
	defer defFunc()
	// Apply logger.
	log.SetLogger(logger)

	test.Suite{
		{Func: testInvalidOptions},
		{Func: testTreeBuilderAggregateEmpty},
		{Func: testTreeBuilderLeafsFromEmptyNotFinalized},
		{Func: testTreeBuilderLeafsFromNotFinalized},
		{Func: testTreeBuilderAddToFinalized},
		{Func: testTreeBuilderDefaultSettings},
		{Func: testTreeBuilderAggrChainInputHash},
		{Func: testTreeBuilderUnbalancedRootHash},
		{Func: testTreeBuilderUnbalancedRootLevel},
		{Func: testTreeBuilderUnbalancedRootLevelAddWithLevel},
		{Func: testTreeBuilderUnbalancedRootLevelAddWithLevelDescending},
		{Func: testTreeBuilderUnbalancedRootLevelAddWithLevelAscending},
		{Func: testTreeBuilderSHA2_512},
		{Func: testTreeBuilderSHA1},
		{Func: testTreeBuilderUserContext},
		{Func: testTreeBuilderListener},
		{Func: testTreeBuilderListenerOnlyAggrListener},
		{Func: testTreeBuilderListenerWithMetadata},
		{Func: testTreeBuilderListenerVerifyAggrHashLevel},
		{Func: testTreeBuilderFailingListenerOnRecordHash},
		{Func: testTreeBuilderFailingListenerOnIntAggrHash},
		{Func: testTreeBuilderFailWithLevelCheckListenerNoEntries},
		{Func: testTreeBuilderMaxLevel},
		{Func: testTreeBuilderExceed0xffAddMeta},
		{Func: testTreeBuilderDefaultMaxLevelAddLvl255},
		{Func: testTreeBuilderWithMetadata},
		{Func: testTreeBuilderWithImprintAsMetadata},
		{Func: testTreeBuilderWithUnsupportedMetadata},
		{Func: testTreeBuilderMaskingWithPrevRecFirstBlock},
		{Func: testTreeBuilderMaskingWithPrevRecAndMetaAsImprint},
		{Func: testTreeBuilderNoMaskingVerifyInputExposed},
		{Func: testTreeBuilderMaskingVerifyInputNotExposed},
		{Func: testTreeBuilderMaskingVerifyInputNotExposedWithIndexMasking},
		{Func: testTreeBuilderNoMaskingMetaAsImprintVerifyRootExposed},
		{Func: testTreeBuilderMaskingWithPrevRecAndMetaAsImprintVerifyInputNotExposed},
		{Func: testTreeBuilderMaskingMetaAsImprintUneven},
		{Func: testTreeBuilderWithMetadataAndBlindingMask},
		{Func: testTreeBuilderWithMetadataAndBlindingMaskNoPreviousLeaf},
		{Func: testTreeBuilderWithBlindingMask},
		{Func: testTreeBuilderWithBlindingMaskNoPreviousLeaf},
		{Func: testAddNodeWithTooLargeLevel},
		{Func: testBuildTooLargeTreeWithNodeMetadataAndLevel},
		{Func: testTreeBuilderMaximumSize},
		{Func: testBuildTooLargeTreeWithBlindingEnabled},
		{Func: testNilTreeAndOptAlgorithm},
		{Func: testNilTreeAndOptMaxLevel},
		{Func: testNilTreeAndOptPreviousLeaf},
		{Func: testTreeOptPreviousLeafInvalid},
		{Func: testNilTreeAndOptInitializationVector},
		{Func: testTreeOptInitializationVectorTooShort},
		{Func: testNilTreeAndOptRecordListener},
		{Func: testTreeOptRecordListenerNil},
		{Func: testNilTreeAndOptMetadataListener},
		{Func: testTreeOptMetadataListenerNil},
		{Func: testNilTreeAndOptAggregateListener},
		{Func: testTreeOptAggregateListenerNil},
		{Func: testAddNodeToNilTree},
		{Func: testAddInvalidNodeToTree},
		{Func: testNilTreeAggregation},
		{Func: testNotInitializedTreeAggregation},
		{Func: testGetLastLeafFromNilTree},
		{Func: testGetLeafsFromNilTree},
		{Func: testGetAggregationChainFromNilTreeNode},
		{Func: testNotInitializedTreeNodeGetAggrChain},
		{Func: testGetCtxFromNilTreeNode},
		{Func: testAddNodeWithLevelToTreeWithBlindingMask},
	}.Runner(t)
}

func testNilTreeAndOptAlgorithm(t *testing.T, _ ...interface{}) {
	treeOpt := TreeOptAlgorithm(hash.SHA2_256)
	if err := treeOpt(nil); err == nil {
		t.Fatal("Should not be possible to set algorithm to nil tree.")
	}
}

func testNilTreeAndOptMaxLevel(t *testing.T, _ ...interface{}) {
	treeOpt := TreeOptMaxLevel(255)
	if err := treeOpt(nil); err == nil {
		t.Fatal("Should not be possible to set max level to nil tree.")
	}
}

func testNilTreeAndOptPreviousLeaf(t *testing.T, _ ...interface{}) {
	var testHsh = []byte{
		0x01, 0x09, 0xA9, 0xFE, 0x43, 0x08, 0x03, 0xD8, 0x98, 0x42, 0x73, 0x32, 0x4C, 0xF4, 0x62, 0xE4, 0x0A, 0x87, 0x5D, 0x48, 0x3D, 0xE6, 0xDD, 0x0D, 0x86, 0xBC, 0x6D, 0xFF, 0x4D, 0x27, 0xC9, 0xD8, 0x53,
	}
	treeOpt := TreeOptMaskingWithPreviousLeaf([]byte{0x12}, testHsh)
	if err := treeOpt(nil); err == nil {
		t.Fatal("Should not be possible to set previous leaf to nil tree.")
	}
}

func testTreeOptPreviousLeafInvalid(t *testing.T, _ ...interface{}) {
	var (
		testHsh = []byte{
			0x01, 0x09, 0xA9, 0xFE, 0x43, 0x08, 0x03, 0xD8, 0x98, 0x42, 0x73, 0x32, 0x4C, 0xF4, 0x62, 0xE4, 0x0A, 0x87, 0x5D, 0x48, 0x3D, 0xE6, 0xDD, 0x0D, 0x86, 0xBC, 0x6D, 0xFF, 0x4D,
		}
		testTree tree
	)
	treeOpt := TreeOptMaskingWithPreviousLeaf([]byte{0x12}, testHsh)
	if err := treeOpt(&testTree); err == nil {
		t.Fatal("Should not be possible to set invalid previous leaf.")
	}
}

func testNilTreeAndOptInitializationVector(t *testing.T, _ ...interface{}) {
	treeOpt := TreeOptMaskingWithPreviousLeaf([]byte{0x98, 0x42, 0x73, 0x32, 0x4C, 0xF4, 0x62}, nil)
	if err := treeOpt(nil); err == nil {
		t.Fatal("Should not be possible to set initialization vector to nil tree.")
	}
}

func testTreeOptInitializationVectorTooShort(t *testing.T, _ ...interface{}) {
	var testTree tree
	treeOpt := TreeOptMaskingWithPreviousLeaf([]byte{}, nil)
	if err := treeOpt(&testTree); err == nil {
		t.Fatal("Should not be possible to set invalid initialization vector.")
	}
}

func testNilTreeAndOptRecordListener(t *testing.T, _ ...interface{}) {
	var hshListener listener.RecordHashListener
	treeOpt := TreeOptRecordListener(hshListener)
	if err := treeOpt(nil); err == nil {
		t.Fatal("Should not be possible to set record hash hshListener to nil tree.")
	}
}

func testTreeOptRecordListenerNil(t *testing.T, _ ...interface{}) {
	var testTree tree
	treeOpt := TreeOptRecordListener(nil)
	if err := treeOpt(&testTree); err == nil {
		t.Fatal("Should not be possible to set nil record hash listener.")
	}
}

func testNilTreeAndOptMetadataListener(t *testing.T, _ ...interface{}) {
	var hshListener listener.MetadataListener
	treeOpt := TreeOptMetadataListener(hshListener)
	if err := treeOpt(nil); err == nil {
		t.Fatal("Should not be possible to set metadata listener to nil tree.")
	}
}

func testTreeOptMetadataListenerNil(t *testing.T, _ ...interface{}) {
	var testTree tree
	treeOpt := TreeOptMetadataListener(nil)
	if err := treeOpt(&testTree); err == nil {
		t.Fatal("Should not be possible to set nil metadata listener.")
	}
}

func testNilTreeAndOptAggregateListener(t *testing.T, _ ...interface{}) {
	var hshListener listener.AggregateHashListener
	treeOpt := TreeOptAggregateListener(hshListener)
	if err := treeOpt(nil); err == nil {
		t.Fatal("Should not be possible to set algorithm to nil tree.")
	}
}

func testTreeOptAggregateListenerNil(t *testing.T, _ ...interface{}) {
	var testTree tree
	treeOpt := TreeOptAggregateListener(nil)
	if err := treeOpt(&testTree); err == nil {
		t.Fatal("Should not be possible to set algorithm to nil tree.")
	}
}

func testAddInvalidNodeToTree(t *testing.T, _ ...interface{}) {
	var tree Tree
	if err := tree.AddNode([]byte{}); err == nil {
		t.Fatal("Should not be possible to add invalid node.")
	}
}

func testAddNodeToNilTree(t *testing.T, _ ...interface{}) {
	var (
		tree    *Tree
		testHsh = []byte{
			0x01, 0x09, 0xA9, 0xFE, 0x43, 0x08, 0x03, 0xD8, 0x98, 0x42, 0x73, 0x32, 0x4C, 0xF4, 0x62, 0xE4, 0x0A, 0x87, 0x5D, 0x48, 0x3D, 0xE6, 0xDD, 0x0D, 0x86, 0xBC, 0x6D, 0xFF, 0x4D, 0x27, 0xC9, 0xD8, 0x53,
		}
	)
	if err := tree.AddNode(testHsh); err == nil {
		t.Fatal("Should not be possible to add node to nil tree.")
	}
}

func testNilTreeAggregation(t *testing.T, _ ...interface{}) {
	var tree *Tree
	if _, _, err := tree.Aggregate(); err == nil {
		t.Fatal("Should not be possible to aggregate nil tree.")
	}
}

func testNotInitializedTreeAggregation(t *testing.T, _ ...interface{}) {
	var tree Tree
	if _, _, err := tree.Aggregate(); err == nil {
		t.Fatal("Should not be possible to aggregate not initialized tree.")
	}
}

func testGetLastLeafFromNilTree(t *testing.T, _ ...interface{}) {
	var tree *Tree
	if _, err := tree.LastLeaf(); err == nil {
		t.Fatal("Should not be possible to get last leaf from nil tree.")
	}
}

func testGetLeafsFromNilTree(t *testing.T, _ ...interface{}) {
	var tree *Tree
	if _, err := tree.Leafs(); err == nil {
		t.Fatal("Should not be possible to get leafs from nil tree.")
	}
}

func testGetAggregationChainFromNilTreeNode(t *testing.T, _ ...interface{}) {
	var node *TreeNode
	if _, err := node.AggregationChain(); err == nil {
		t.Fatal("Should not be possible to get aggregation chain from nil tree node.")
	}
}

func testNotInitializedTreeNodeGetAggrChain(t *testing.T, _ ...interface{}) {
	var node TreeNode
	if _, err := node.AggregationChain(); err == nil {
		t.Fatal("Should not be possible to get aggregation chain from not initialized tree node.")
	}
}

func testGetCtxFromNilTreeNode(t *testing.T, _ ...interface{}) {
	var node *TreeNode
	if _, err := node.UserCtx(); err == nil {
		t.Fatal("Should not be possible to get user context from nil tree node.")
	}
}

func testAddNodeWithLevelToTreeWithBlindingMask(t *testing.T, _ ...interface{}) {
	var testHsh = []byte{
		0x01, 0x09, 0xA9, 0xFE, 0x43, 0x08, 0x03, 0xD8, 0x98, 0x42, 0x73, 0x32, 0x4C, 0xF4, 0x62, 0xE4, 0x0A, 0x87, 0x5D, 0x48, 0x3D, 0xE6, 0xDD, 0x0D, 0x86, 0xBC, 0x6D, 0xFF, 0x4D, 0x27, 0xC9, 0xD8, 0x53,
	}
	tree, err := New(TreeOptMaskingWithPreviousLeaf([]byte{0x98, 0x42, 0x73, 0x32, 0x4C, 0xF4, 0x62},
		utils.StringToBin("0109A9FE430803D8984273324CF462E40A875D483DE6DD0D86BC6DFF4D27C9D853")))
	if err != nil {
		t.Fatal("Failed to create a tree builder with IV: ", err)
	}
	if err = tree.AddNode(testHsh, InputHashOptionLevel(12)); err == nil {
		t.Fatal("Should not be possible to add a node with level to the tree that is using blinding mask.")
	}
}

func assertInvalidTreeOpt(t *testing.T, msg string, opt ...TreeOpt) {
	_, err := New(opt...)
	if err == nil {
		t.Fatal("This calls should have been failed!")
	}

	ksiErr := errors.KsiErr(err)
	errCode := ksiErr.Code()
	errMsg := ksiErr.Message()[0]

	if errCode != errors.KsiInvalidArgumentError {
		t.Fatal("Unexpected error. Expecting KsiInvalidArgumentError ut got: ", err)
	}

	if errMsg != msg {
		t.Fatalf("Expecting error '%s', but got '%s'", msg, errMsg)
	}
}

func testInvalidOptions(t *testing.T, _ ...interface{}) {
	var (
		iv       = []byte{1, 1, 1, 1}
		prevLeaf = hash.Default.ZeroImprint()
	)

	assertInvalidTreeOpt(t, "Invalid last leaf imprint.", TreeOptMaskingWithPreviousLeaf(nil, nil))
	assertInvalidTreeOpt(t, "Invalid last leaf imprint.", TreeOptMaskingWithPreviousLeaf(iv, nil))
	assertInvalidTreeOpt(t, "Missing IV.", TreeOptMaskingWithPreviousLeaf(nil, prevLeaf))
	assertInvalidTreeOpt(t, "Missing IV.", TreeOptMaskingWithIndex(nil))

	assertInvalidTreeOpt(t, "Missing record listener.", TreeOptRecordListener(nil))
	assertInvalidTreeOpt(t, "Missing metadata listener.", TreeOptMetadataListener(nil))
	assertInvalidTreeOpt(t, "Missing aggregate listener.", TreeOptAggregateListener(nil))

	assertInvalidTreeOpt(t, "Invalid hash algorithm.", TreeOptAlgorithm(hash.SHA1))
}

func testTreeBuilderAggregateEmpty(t *testing.T, _ ...interface{}) {
	tree, err := New()
	if err != nil {
		t.Fatal("Failed to create tree builder: ", err)
	}

	rootHsh, _, err := tree.Aggregate()
	if err == nil {
		t.Error("Error must be returned.")
	}
	if rootHsh != nil {
		t.Error("There should be no root hash returned.")
	}
}

func testTreeBuilderLeafsFromEmptyNotFinalized(t *testing.T, _ ...interface{}) {
	tree, err := New()
	if err != nil {
		t.Fatal("Failed to create tree builder: ", err)
	}

	leafs, err := tree.Leafs()
	if err == nil {
		t.Error("Error must be returned.")
	}
	if leafs != nil {
		t.Error("No leafs should be returned.")
	}
}

func testTreeBuilderLeafsFromNotFinalized(t *testing.T, _ ...interface{}) {
	var (
		testHsh = []byte{
			0x01, 0x09, 0xA9, 0xFE, 0x43, 0x08, 0x03, 0xD8, 0x98, 0x42, 0x73, 0x32, 0x4C, 0xF4, 0x62, 0xE4, 0x0A, 0x87, 0x5D, 0x48, 0x3D, 0xE6, 0xDD, 0x0D, 0x86, 0xBC, 0x6D, 0xFF, 0x4D, 0x27, 0xC9, 0xD8, 0x53,
		}
	)

	tree, err := New()
	if err != nil {
		t.Fatal("Failed to create tree builder: ", err)
	}

	if err := tree.AddNode(testHsh); err != nil {
		t.Fatal("Failed to add tree node: ", err)
	}

	leafs, err := tree.Leafs()
	if err == nil {
		t.Error("Error must be returned.")
	}
	if leafs != nil {
		t.Error("No leafs should be returned.")
	}
}

func testTreeBuilderAddToFinalized(t *testing.T, _ ...interface{}) {
	var (
		testHsh = []byte{
			0x01, 0x09, 0xA9, 0xFE, 0x43, 0x08, 0x03, 0xD8, 0x98, 0x42, 0x73, 0x32, 0x4C, 0xF4, 0x62, 0xE4, 0x0A, 0x87, 0x5D, 0x48, 0x3D, 0xE6, 0xDD, 0x0D, 0x86, 0xBC, 0x6D, 0xFF, 0x4D, 0x27, 0xC9, 0xD8, 0x53,
		}
	)

	tree, err := New()
	if err != nil {
		t.Fatal("Failed to create tree builder: ", err)
	}

	if err = tree.AddNode(testHsh); err != nil {
		t.Fatal("Failed to add tree node: ", err)
	}

	if _, _, err = tree.Aggregate(); err != nil {
		t.Fatal("Failed to aggregate: ", err)
	}

	if err := tree.AddNode(testHsh); err == nil {
		t.Fatal("Adding new leafs to a finalized tree is prohibited.")
	}
}

func testTreeBuilderDefaultSettings(t *testing.T, _ ...interface{}) {

	var (
		testData = [][]byte{
			{0x01, 0x09, 0xA9, 0xFE, 0x43, 0x08, 0x03, 0xD8, 0x98, 0x42, 0x73, 0x32, 0x4C, 0xF4, 0x62, 0xE4, 0x0A, 0x87, 0x5D, 0x48, 0x3D, 0xE6, 0xDD, 0x0D, 0x86, 0xBC, 0x6D, 0xFF, 0x4D, 0x27, 0xC9, 0xD8, 0x53},
			{0x01, 0xBE, 0xC8, 0x4E, 0x1F, 0x95, 0xF7, 0x29, 0xF4, 0x48, 0x23, 0x38, 0xE7, 0x81, 0x34, 0x1B, 0x16, 0x15, 0xF5, 0xB0, 0xA8, 0x82, 0x23, 0x1A, 0xE6, 0xC0, 0xFA, 0xEF, 0x7D, 0x0E, 0x61, 0x21, 0xD5},
			{0x01, 0xC7, 0x34, 0xEE, 0xFE, 0x09, 0xB6, 0xB7, 0x17, 0xB0, 0xBA, 0x69, 0x97, 0xCA, 0x63, 0x4A, 0xDB, 0x93, 0xE2, 0xF2, 0x27, 0xBE, 0xB7, 0x85, 0xBB, 0xB8, 0xB4, 0x47, 0x26, 0x51, 0x08, 0x45, 0x09},
			{0x01, 0xB0, 0xCF, 0x0A, 0x7E, 0x6E, 0x04, 0x20, 0xD2, 0x7C, 0xDF, 0xA1, 0x1B, 0xDF, 0xAC, 0x4A, 0xA9, 0xBC, 0x77, 0x7A, 0xE4, 0xD6, 0xC0, 0x21, 0x18, 0x16, 0xBC, 0xB9, 0x1D, 0xE7, 0xC9, 0x20, 0xAD},
		}
		testRootHsh = []byte{
			0x01, 0x64, 0x59, 0x7a, 0x59, 0x84, 0xe8, 0x68, 0x2b, 0x5d, 0x6e, 0x3b, 0x15, 0xdd, 0x73, 0x1d, 0xdf, 0xeb, 0x8e, 0x72, 0x8e, 0x60, 0x8b, 0x6b, 0x1f, 0xc9, 0x1a, 0x1f, 0x01, 0x46, 0x7a, 0xa2, 0xc4,
		}
	)

	tree, err := New()
	if err != nil {
		t.Fatal("Failed to create tree builder: ", err)
	}

	for i, hsh := range testData {
		if err := tree.AddNode(hsh); err != nil {
			t.Fatal("Failed to add tree node: ", err)
		}

		p, err := tree.Count()
		if err != nil {
			t.Fatal("Failed to get tree count: ", err)
		}

		if i != p-1 {
			t.Error("Position mismatch.")
		}
	}

	rootHsh, _, err := tree.Aggregate()
	if err != nil {
		t.Fatal("Failed to close tree: ", err)
	}

	if !hash.Equal(testRootHsh, rootHsh) {
		t.Fatal("Root hash mismatch.")
	}

	leafs, err := tree.Leafs()
	if err != nil {
		t.Fatal("Failed to get tree leafs: ", err)
	}
	if len(leafs) != len(testData) {
		t.Fatal("Nof tree leafs mismatch")
	}
}

func testTreeBuilderAggrChainInputHash(t *testing.T, _ ...interface{}) {

	var (
		testData = [][]byte{
			{0x01, 0x09, 0xA9, 0xFE, 0x43, 0x08, 0x03, 0xD8, 0x98, 0x42, 0x73, 0x32, 0x4C, 0xF4, 0x62, 0xE4, 0x0A, 0x87, 0x5D, 0x48, 0x3D, 0xE6, 0xDD, 0x0D, 0x86, 0xBC, 0x6D, 0xFF, 0x4D, 0x27, 0xC9, 0xD8, 0x53},
			{0x01, 0xBE, 0xC8, 0x4E, 0x1F, 0x95, 0xF7, 0x29, 0xF4, 0x48, 0x23, 0x38, 0xE7, 0x81, 0x34, 0x1B, 0x16, 0x15, 0xF5, 0xB0, 0xA8, 0x82, 0x23, 0x1A, 0xE6, 0xC0, 0xFA, 0xEF, 0x7D, 0x0E, 0x61, 0x21, 0xD5},
			{0x01, 0xC7, 0x34, 0xEE, 0xFE, 0x09, 0xB6, 0xB7, 0x17, 0xB0, 0xBA, 0x69, 0x97, 0xCA, 0x63, 0x4A, 0xDB, 0x93, 0xE2, 0xF2, 0x27, 0xBE, 0xB7, 0x85, 0xBB, 0xB8, 0xB4, 0x47, 0x26, 0x51, 0x08, 0x45, 0x09},
			{0x01, 0xB0, 0xCF, 0x0A, 0x7E, 0x6E, 0x04, 0x20, 0xD2, 0x7C, 0xDF, 0xA1, 0x1B, 0xDF, 0xAC, 0x4A, 0xA9, 0xBC, 0x77, 0x7A, 0xE4, 0xD6, 0xC0, 0x21, 0x18, 0x16, 0xBC, 0xB9, 0x1D, 0xE7, 0xC9, 0x20, 0xAD},
		}
	)

	tree, err := New()
	if err != nil {
		t.Fatal("Failed to create tree builder: ", err)
	}

	for _, hsh := range testData {
		if err := tree.AddNode(hsh); err != nil {
			t.Fatal("Failed to add tree node: ", err)
		}
	}

	if _, _, err := tree.Aggregate(); err != nil {
		t.Fatal("Failed to close tree: ", err)
	}

	leafs, err := tree.Leafs()
	if err != nil {
		t.Fatal("Failed to get tree leafs: ", err)
	}
	for i, leaf := range leafs {
		chain, err := leaf.AggregationChain()
		if err != nil {
			t.Fatal("Failed to get aggregation chain: ", err)
		}

		inputHash, err := chain.InputHash()
		if inputHash == nil {
			t.Fatal("Missing input hash.")
		}
		if !hash.Equal(testData[i], inputHash) {
			t.Fatal("Input hash mismatch.")
		}
	}
}

func testTreeBuilderUnbalancedRootHash(t *testing.T, _ ...interface{}) {

	var (
		testData = [][]byte{
			{0x01, 0x09, 0xA9, 0xFE, 0x43, 0x08, 0x03, 0xD8, 0x98, 0x42, 0x73, 0x32, 0x4C, 0xF4, 0x62, 0xE4, 0x0A, 0x87, 0x5D, 0x48, 0x3D, 0xE6, 0xDD, 0x0D, 0x86, 0xBC, 0x6D, 0xFF, 0x4D, 0x27, 0xC9, 0xD8, 0x53},
			{0x01, 0xBE, 0xC8, 0x4E, 0x1F, 0x95, 0xF7, 0x29, 0xF4, 0x48, 0x23, 0x38, 0xE7, 0x81, 0x34, 0x1B, 0x16, 0x15, 0xF5, 0xB0, 0xA8, 0x82, 0x23, 0x1A, 0xE6, 0xC0, 0xFA, 0xEF, 0x7D, 0x0E, 0x61, 0x21, 0xD5},
			{0x01, 0xC7, 0x34, 0xEE, 0xFE, 0x09, 0xB6, 0xB7, 0x17, 0xB0, 0xBA, 0x69, 0x97, 0xCA, 0x63, 0x4A, 0xDB, 0x93, 0xE2, 0xF2, 0x27, 0xBE, 0xB7, 0x85, 0xBB, 0xB8, 0xB4, 0x47, 0x26, 0x51, 0x08, 0x45, 0x09},
			{0x01, 0xB0, 0xCF, 0x0A, 0x7E, 0x6E, 0x04, 0x20, 0xD2, 0x7C, 0xDF, 0xA1, 0x1B, 0xDF, 0xAC, 0x4A, 0xA9, 0xBC, 0x77, 0x7A, 0xE4, 0xD6, 0xC0, 0x21, 0x18, 0x16, 0xBC, 0xB9, 0x1D, 0xE7, 0xC9, 0x20, 0xAD},
			{0x01, 0xBB, 0x95, 0xE9, 0xB0, 0x9E, 0x7F, 0x6B, 0xC9, 0x55, 0x33, 0xD8, 0x05, 0x73, 0x9E, 0x26, 0x51, 0x0A, 0x05, 0xF9, 0x78, 0x8A, 0x86, 0xC7, 0xF8, 0x1B, 0xA8, 0xF8, 0x1E, 0x0E, 0x6C, 0x43, 0xDA},
			{0x01, 0x79, 0x43, 0xB1, 0xF4, 0x52, 0x14, 0x25, 0xE1, 0x1B, 0x46, 0x1A, 0x76, 0xB9, 0xF4, 0x6B, 0x08, 0x98, 0x0F, 0xFD, 0x04, 0xCD, 0x08, 0x04, 0x97, 0xD5, 0x5A, 0x8C, 0x06, 0x3E, 0x6D, 0xCD, 0xF7},
			{0x01, 0x23, 0xC4, 0xAD, 0xE3, 0xB6, 0x4A, 0x45, 0x69, 0x40, 0x88, 0xFD, 0x42, 0x73, 0x99, 0xD3, 0xC2, 0xEC, 0x12, 0x0B, 0xB0, 0xD5, 0xDF, 0x8C, 0x52, 0x12, 0xB1, 0x56, 0x2F, 0x8D, 0x82, 0x19, 0x02},
			{0x01, 0xA3, 0x60, 0xBB, 0xAE, 0x9A, 0x02, 0x15, 0x19, 0x64, 0x49, 0x97, 0x1E, 0x57, 0xEB, 0x91, 0xB6, 0xC9, 0xB3, 0x97, 0x25, 0x40, 0x83, 0x24, 0xBE, 0x32, 0x5D, 0x40, 0xC2, 0x54, 0x35, 0x3F, 0xBF},
			{0x01, 0x03, 0x47, 0xA3, 0xE6, 0xC1, 0x6B, 0x74, 0x34, 0x73, 0xCE, 0xCD, 0x6C, 0xAA, 0xD8, 0x13, 0x46, 0x4F, 0x8B, 0x8B, 0xD0, 0x38, 0x29, 0xF6, 0x49, 0xDD, 0x2F, 0xD3, 0xBA, 0x60, 0xD0, 0x2E, 0xCD},
			{0x01, 0x78, 0xC6, 0x30, 0x34, 0x84, 0x6B, 0x2C, 0x6E, 0x67, 0x21, 0x8F, 0xBD, 0x9F, 0x58, 0x33, 0x30, 0x44, 0x2A, 0x99, 0xD7, 0x16, 0x54, 0x92, 0xFA, 0x57, 0x32, 0x02, 0x4F, 0x27, 0xFE, 0x7F, 0xFA},
			{0x01, 0x05, 0x79, 0xA7, 0x76, 0x55, 0x8F, 0xE4, 0x84, 0x56, 0xA3, 0x0E, 0x56, 0xB9, 0xBF, 0x58, 0xE5, 0x95, 0xFF, 0x7D, 0x4D, 0xF0, 0x49, 0x27, 0x5C, 0x0D, 0x0E, 0xD5, 0xB3, 0x61, 0xE9, 0x13, 0x82},
		}
		testRootHsh = []byte{
			0x01, 0xb6, 0xb2, 0x30, 0x0c, 0xff, 0x39, 0x71, 0xd1, 0xef, 0x8c, 0xe6, 0x72, 0x8a, 0x85, 0x5d, 0x77, 0xa1, 0xee, 0x93, 0xba, 0x91, 0xf8, 0xba, 0xff, 0x59, 0x57, 0x1b, 0x44, 0xe4, 0x99, 0x64, 0xcf,
		}
	)

	tree, err := New()
	if err != nil {
		t.Fatal("Failed to create tree builder: ", err)
	}

	for i, hsh := range testData {
		if err := tree.AddNode(hsh); err != nil {
			t.Fatal("Failed to add tree node: ", err)
		}

		p, err := tree.Count()
		if err != nil {
			t.Fatal("Failed to get tree count: ", err)
		}

		if i != p-1 {
			t.Error("Position mismatch.")
		}
	}

	rootHsh, _, err := tree.Aggregate()
	if err != nil {
		t.Fatal("Failed to close tree: ", err)
	}
	if !hash.Equal(testRootHsh, rootHsh) {
		t.Fatal("Root hash mismatch.")
	}

	leafs, err := tree.Leafs()
	if err != nil {
		t.Fatal("Failed to get tree leafs: ", err)
	}
	for _, l := range leafs {
		chain, err := l.AggregationChain()
		if err != nil {
			t.Fatal("Failed to leaf aggregation hash chain: ", err)
		}

		hsh, _, err := chain.Aggregate(0)
		if err != nil {
			t.Fatal("Failed to aggregate aggregation hash chain: ", err)
		}
		if !hash.Equal(testRootHsh, hsh) {
			t.Fatal("Aggregated root hash mismatch.")
		}
	}

}

func testTreeBuilderUnbalancedRootLevel(t *testing.T, _ ...interface{}) {

	var (
		testData = [][]byte{
			{0x01, 0x09, 0xA9, 0xFE, 0x43, 0x08, 0x03, 0xD8, 0x98, 0x42, 0x73, 0x32, 0x4C, 0xF4, 0x62, 0xE4, 0x0A, 0x87, 0x5D, 0x48, 0x3D, 0xE6, 0xDD, 0x0D, 0x86, 0xBC, 0x6D, 0xFF, 0x4D, 0x27, 0xC9, 0xD8, 0x53},
			{0x01, 0xBE, 0xC8, 0x4E, 0x1F, 0x95, 0xF7, 0x29, 0xF4, 0x48, 0x23, 0x38, 0xE7, 0x81, 0x34, 0x1B, 0x16, 0x15, 0xF5, 0xB0, 0xA8, 0x82, 0x23, 0x1A, 0xE6, 0xC0, 0xFA, 0xEF, 0x7D, 0x0E, 0x61, 0x21, 0xD5},
			{0x01, 0xC7, 0x34, 0xEE, 0xFE, 0x09, 0xB6, 0xB7, 0x17, 0xB0, 0xBA, 0x69, 0x97, 0xCA, 0x63, 0x4A, 0xDB, 0x93, 0xE2, 0xF2, 0x27, 0xBE, 0xB7, 0x85, 0xBB, 0xB8, 0xB4, 0x47, 0x26, 0x51, 0x08, 0x45, 0x09},
			{0x01, 0xB0, 0xCF, 0x0A, 0x7E, 0x6E, 0x04, 0x20, 0xD2, 0x7C, 0xDF, 0xA1, 0x1B, 0xDF, 0xAC, 0x4A, 0xA9, 0xBC, 0x77, 0x7A, 0xE4, 0xD6, 0xC0, 0x21, 0x18, 0x16, 0xBC, 0xB9, 0x1D, 0xE7, 0xC9, 0x20, 0xAD},
			{0x01, 0xBB, 0x95, 0xE9, 0xB0, 0x9E, 0x7F, 0x6B, 0xC9, 0x55, 0x33, 0xD8, 0x05, 0x73, 0x9E, 0x26, 0x51, 0x0A, 0x05, 0xF9, 0x78, 0x8A, 0x86, 0xC7, 0xF8, 0x1B, 0xA8, 0xF8, 0x1E, 0x0E, 0x6C, 0x43, 0xDA},
			{0x01, 0x79, 0x43, 0xB1, 0xF4, 0x52, 0x14, 0x25, 0xE1, 0x1B, 0x46, 0x1A, 0x76, 0xB9, 0xF4, 0x6B, 0x08, 0x98, 0x0F, 0xFD, 0x04, 0xCD, 0x08, 0x04, 0x97, 0xD5, 0x5A, 0x8C, 0x06, 0x3E, 0x6D, 0xCD, 0xF7},
			{0x01, 0x23, 0xC4, 0xAD, 0xE3, 0xB6, 0x4A, 0x45, 0x69, 0x40, 0x88, 0xFD, 0x42, 0x73, 0x99, 0xD3, 0xC2, 0xEC, 0x12, 0x0B, 0xB0, 0xD5, 0xDF, 0x8C, 0x52, 0x12, 0xB1, 0x56, 0x2F, 0x8D, 0x82, 0x19, 0x02},
			{0x01, 0xA3, 0x60, 0xBB, 0xAE, 0x9A, 0x02, 0x15, 0x19, 0x64, 0x49, 0x97, 0x1E, 0x57, 0xEB, 0x91, 0xB6, 0xC9, 0xB3, 0x97, 0x25, 0x40, 0x83, 0x24, 0xBE, 0x32, 0x5D, 0x40, 0xC2, 0x54, 0x35, 0x3F, 0xBF},
			{0x01, 0x03, 0x47, 0xA3, 0xE6, 0xC1, 0x6B, 0x74, 0x34, 0x73, 0xCE, 0xCD, 0x6C, 0xAA, 0xD8, 0x13, 0x46, 0x4F, 0x8B, 0x8B, 0xD0, 0x38, 0x29, 0xF6, 0x49, 0xDD, 0x2F, 0xD3, 0xBA, 0x60, 0xD0, 0x2E, 0xCD},
			{0x01, 0x78, 0xC6, 0x30, 0x34, 0x84, 0x6B, 0x2C, 0x6E, 0x67, 0x21, 0x8F, 0xBD, 0x9F, 0x58, 0x33, 0x30, 0x44, 0x2A, 0x99, 0xD7, 0x16, 0x54, 0x92, 0xFA, 0x57, 0x32, 0x02, 0x4F, 0x27, 0xFE, 0x7F, 0xFA},
			{0x01, 0x05, 0x79, 0xA7, 0x76, 0x55, 0x8F, 0xE4, 0x84, 0x56, 0xA3, 0x0E, 0x56, 0xB9, 0xBF, 0x58, 0xE5, 0x95, 0xFF, 0x7D, 0x4D, 0xF0, 0x49, 0x27, 0x5C, 0x0D, 0x0E, 0xD5, 0xB3, 0x61, 0xE9, 0x13, 0x82},
		}
		testRootLvl byte = 4
	)

	tree, err := New()
	if err != nil {
		t.Fatal("Failed to create tree builder: ", err)
	}

	for _, hsh := range testData {
		if err := tree.AddNode(hsh); err != nil {
			t.Fatal("Failed to add tree node: ", err)
		}
	}

	_, rootLvl, err := tree.Aggregate()
	if err != nil {
		t.Fatal("Failed to close tree: ", err)
	}
	if rootLvl != testRootLvl {
		t.Fatal("Tree root level mismatch.")
	}

	leafs, err := tree.Leafs()
	if err != nil {
		t.Fatal("Failed to get tree leafs: ", err)
	}
	for _, l := range leafs {
		chain, err := l.AggregationChain()
		if err != nil {
			t.Fatal("Failed to leaf aggregation hash chain: ", err)
		}

		_, lvl, err := chain.Aggregate(0)
		if err != nil {
			t.Fatal("Failed to aggregate aggregation hash chain: ", err)
		}
		if testRootLvl != lvl {
			t.Fatal("Aggregated root level mismatch.")
		}
	}
}

func testTreeBuilderUnbalancedRootLevelAddWithLevel(t *testing.T, _ ...interface{}) {
	var (
		testData = []struct {
			lvl byte
			hsh []byte
		}{
			{0, []byte{0x01, 0x09, 0xA9, 0xFE, 0x43, 0x08, 0x03, 0xD8, 0x98, 0x42, 0x73, 0x32, 0x4C, 0xF4, 0x62, 0xE4, 0x0A, 0x87, 0x5D, 0x48, 0x3D, 0xE6, 0xDD, 0x0D, 0x86, 0xBC, 0x6D, 0xFF, 0x4D, 0x27, 0xC9, 0xD8, 0x53}},
			{0, []byte{0x01, 0xBE, 0xC8, 0x4E, 0x1F, 0x95, 0xF7, 0x29, 0xF4, 0x48, 0x23, 0x38, 0xE7, 0x81, 0x34, 0x1B, 0x16, 0x15, 0xF5, 0xB0, 0xA8, 0x82, 0x23, 0x1A, 0xE6, 0xC0, 0xFA, 0xEF, 0x7D, 0x0E, 0x61, 0x21, 0xD5}},
			{0, []byte{0x01, 0xC7, 0x34, 0xEE, 0xFE, 0x09, 0xB6, 0xB7, 0x17, 0xB0, 0xBA, 0x69, 0x97, 0xCA, 0x63, 0x4A, 0xDB, 0x93, 0xE2, 0xF2, 0x27, 0xBE, 0xB7, 0x85, 0xBB, 0xB8, 0xB4, 0x47, 0x26, 0x51, 0x08, 0x45, 0x09}},
			{2, []byte{0x01, 0xB0, 0xCF, 0x0A, 0x7E, 0x6E, 0x04, 0x20, 0xD2, 0x7C, 0xDF, 0xA1, 0x1B, 0xDF, 0xAC, 0x4A, 0xA9, 0xBC, 0x77, 0x7A, 0xE4, 0xD6, 0xC0, 0x21, 0x18, 0x16, 0xBC, 0xB9, 0x1D, 0xE7, 0xC9, 0x20, 0xAD}},
			{1, []byte{0x01, 0xBB, 0x95, 0xE9, 0xB0, 0x9E, 0x7F, 0x6B, 0xC9, 0x55, 0x33, 0xD8, 0x05, 0x73, 0x9E, 0x26, 0x51, 0x0A, 0x05, 0xF9, 0x78, 0x8A, 0x86, 0xC7, 0xF8, 0x1B, 0xA8, 0xF8, 0x1E, 0x0E, 0x6C, 0x43, 0xDA}},
			{4, []byte{0x01, 0x79, 0x43, 0xB1, 0xF4, 0x52, 0x14, 0x25, 0xE1, 0x1B, 0x46, 0x1A, 0x76, 0xB9, 0xF4, 0x6B, 0x08, 0x98, 0x0F, 0xFD, 0x04, 0xCD, 0x08, 0x04, 0x97, 0xD5, 0x5A, 0x8C, 0x06, 0x3E, 0x6D, 0xCD, 0xF7}},
			{2, []byte{0x01, 0x23, 0xC4, 0xAD, 0xE3, 0xB6, 0x4A, 0x45, 0x69, 0x40, 0x88, 0xFD, 0x42, 0x73, 0x99, 0xD3, 0xC2, 0xEC, 0x12, 0x0B, 0xB0, 0xD5, 0xDF, 0x8C, 0x52, 0x12, 0xB1, 0x56, 0x2F, 0x8D, 0x82, 0x19, 0x02}},
			{1, []byte{0x01, 0xA3, 0x60, 0xBB, 0xAE, 0x9A, 0x02, 0x15, 0x19, 0x64, 0x49, 0x97, 0x1E, 0x57, 0xEB, 0x91, 0xB6, 0xC9, 0xB3, 0x97, 0x25, 0x40, 0x83, 0x24, 0xBE, 0x32, 0x5D, 0x40, 0xC2, 0x54, 0x35, 0x3F, 0xBF}},
			{6, []byte{0x01, 0x03, 0x47, 0xA3, 0xE6, 0xC1, 0x6B, 0x74, 0x34, 0x73, 0xCE, 0xCD, 0x6C, 0xAA, 0xD8, 0x13, 0x46, 0x4F, 0x8B, 0x8B, 0xD0, 0x38, 0x29, 0xF6, 0x49, 0xDD, 0x2F, 0xD3, 0xBA, 0x60, 0xD0, 0x2E, 0xCD}},
			{0, []byte{0x01, 0x78, 0xC6, 0x30, 0x34, 0x84, 0x6B, 0x2C, 0x6E, 0x67, 0x21, 0x8F, 0xBD, 0x9F, 0x58, 0x33, 0x30, 0x44, 0x2A, 0x99, 0xD7, 0x16, 0x54, 0x92, 0xFA, 0x57, 0x32, 0x02, 0x4F, 0x27, 0xFE, 0x7F, 0xFA}},
		}
		testRootLvl byte = 8
	)

	tree, err := New()
	if err != nil {
		t.Fatal("Failed to create tree builder: ", err)
	}

	for _, d := range testData {
		if err = tree.AddNode(d.hsh, InputHashOptionLevel(d.lvl), InputHashOptionUserContext(d.lvl)); err != nil {
			t.Fatal("Failed to add tree node: ", err)
		}
	}

	_, rootLvl, err := tree.Aggregate()
	if err != nil {
		t.Fatal("Failed to close tree: ", err)
	}
	if rootLvl != testRootLvl {
		t.Fatal("Tree root level mismatch.")
	}

	leafs, err := tree.Leafs()
	if err != nil {
		t.Fatal("Failed to get tree leafs: ", err)
	}
	for _, l := range leafs {
		chain, err := l.AggregationChain()
		if err != nil {
			t.Fatal("Failed to get leaf aggregation hash chain: ", err)
		}

		ctxLvl, err := l.UserCtx()
		if err != nil {
			t.Fatal("Failed to get user context: ", err)
		}
		nodeLvl, err := l.Level()
		if err != nil {
			t.Fatal("Failed to get node level: ", err)
		}
		if ctxLvl != nodeLvl {
			t.Fatal("Input level mismatch.")
		}

		_, lvl, err := chain.Aggregate(nodeLvl)
		if err != nil {
			t.Fatal("Failed to aggregate aggregation hash chain: ", err)
		}
		if testRootLvl != lvl {
			t.Fatal("Aggregated root level mismatch.")
		}
	}
}

type testRecordData struct {
	lvl byte
	hsh []byte
}

func testTreeBuilderUnbalancedRootLevelAddWithLevelDescending(t *testing.T, _ ...interface{}) {
	const (
		testExpectedRootLvl byte = 255
		testExtraRecordLvl  byte = 254
	)
	var (
		testData = []testRecordData{
			{251, []byte{0x01, 0x09, 0xA9, 0xFE, 0x43, 0x08, 0x03, 0xD8, 0x98, 0x42, 0x73, 0x32, 0x4C, 0xF4, 0x62, 0xE4, 0x0A, 0x87, 0x5D, 0x48, 0x3D, 0xE6, 0xDD, 0x0D, 0x86, 0xBC, 0x6D, 0xFF, 0x4D, 0x27, 0xC9, 0xD8, 0x53}},
			{128, []byte{0x01, 0xBE, 0xC8, 0x4E, 0x1F, 0x95, 0xF7, 0x29, 0xF4, 0x48, 0x23, 0x38, 0xE7, 0x81, 0x34, 0x1B, 0x16, 0x15, 0xF5, 0xB0, 0xA8, 0x82, 0x23, 0x1A, 0xE6, 0xC0, 0xFA, 0xEF, 0x7D, 0x0E, 0x61, 0x21, 0xD5}},
			{64, []byte{0x01, 0xC7, 0x34, 0xEE, 0xFE, 0x09, 0xB6, 0xB7, 0x17, 0xB0, 0xBA, 0x69, 0x97, 0xCA, 0x63, 0x4A, 0xDB, 0x93, 0xE2, 0xF2, 0x27, 0xBE, 0xB7, 0x85, 0xBB, 0xB8, 0xB4, 0x47, 0x26, 0x51, 0x08, 0x45, 0x09}},
			{32, []byte{0x01, 0xB0, 0xCF, 0x0A, 0x7E, 0x6E, 0x04, 0x20, 0xD2, 0x7C, 0xDF, 0xA1, 0x1B, 0xDF, 0xAC, 0x4A, 0xA9, 0xBC, 0x77, 0x7A, 0xE4, 0xD6, 0xC0, 0x21, 0x18, 0x16, 0xBC, 0xB9, 0x1D, 0xE7, 0xC9, 0x20, 0xAD}},
			{16, []byte{0x01, 0xBB, 0x95, 0xE9, 0xB0, 0x9E, 0x7F, 0x6B, 0xC9, 0x55, 0x33, 0xD8, 0x05, 0x73, 0x9E, 0x26, 0x51, 0x0A, 0x05, 0xF9, 0x78, 0x8A, 0x86, 0xC7, 0xF8, 0x1B, 0xA8, 0xF8, 0x1E, 0x0E, 0x6C, 0x43, 0xDA}},
			{8, []byte{0x01, 0x79, 0x43, 0xB1, 0xF4, 0x52, 0x14, 0x25, 0xE1, 0x1B, 0x46, 0x1A, 0x76, 0xB9, 0xF4, 0x6B, 0x08, 0x98, 0x0F, 0xFD, 0x04, 0xCD, 0x08, 0x04, 0x97, 0xD5, 0x5A, 0x8C, 0x06, 0x3E, 0x6D, 0xCD, 0xF7}},
			{4, []byte{0x01, 0x23, 0xC4, 0xAD, 0xE3, 0xB6, 0x4A, 0x45, 0x69, 0x40, 0x88, 0xFD, 0x42, 0x73, 0x99, 0xD3, 0xC2, 0xEC, 0x12, 0x0B, 0xB0, 0xD5, 0xDF, 0x8C, 0x52, 0x12, 0xB1, 0x56, 0x2F, 0x8D, 0x82, 0x19, 0x02}},
			{2, []byte{0x01, 0xA3, 0x60, 0xBB, 0xAE, 0x9A, 0x02, 0x15, 0x19, 0x64, 0x49, 0x97, 0x1E, 0x57, 0xEB, 0x91, 0xB6, 0xC9, 0xB3, 0x97, 0x25, 0x40, 0x83, 0x24, 0xBE, 0x32, 0x5D, 0x40, 0xC2, 0x54, 0x35, 0x3F, 0xBF}},
			{1, []byte{0x01, 0x03, 0x47, 0xA3, 0xE6, 0xC1, 0x6B, 0x74, 0x34, 0x73, 0xCE, 0xCD, 0x6C, 0xAA, 0xD8, 0x13, 0x46, 0x4F, 0x8B, 0x8B, 0xD0, 0x38, 0x29, 0xF6, 0x49, 0xDD, 0x2F, 0xD3, 0xBA, 0x60, 0xD0, 0x2E, 0xCD}},
			{0, []byte{0x01, 0x78, 0xC6, 0x30, 0x34, 0x84, 0x6B, 0x2C, 0x6E, 0x67, 0x21, 0x8F, 0xBD, 0x9F, 0x58, 0x33, 0x30, 0x44, 0x2A, 0x99, 0xD7, 0x16, 0x54, 0x92, 0xFA, 0x57, 0x32, 0x02, 0x4F, 0x27, 0xFE, 0x7F, 0xFA}},
		}
	)
	verifyExpectedRootLevel(t, testExpectedRootLvl, testData, testExtraRecordLvl)
}

func testTreeBuilderUnbalancedRootLevelAddWithLevelAscending(t *testing.T, _ ...interface{}) {
	const (
		testExpectedRootLvl byte = 255
		testExtraRecordLvl  byte = 0
	)
	var (
		testData = []testRecordData{
			{0, []byte{0x01, 0x09, 0xA9, 0xFE, 0x43, 0x08, 0x03, 0xD8, 0x98, 0x42, 0x73, 0x32, 0x4C, 0xF4, 0x62, 0xE4, 0x0A, 0x87, 0x5D, 0x48, 0x3D, 0xE6, 0xDD, 0x0D, 0x86, 0xBC, 0x6D, 0xFF, 0x4D, 0x27, 0xC9, 0xD8, 0x53}},
			{1, []byte{0x01, 0xBE, 0xC8, 0x4E, 0x1F, 0x95, 0xF7, 0x29, 0xF4, 0x48, 0x23, 0x38, 0xE7, 0x81, 0x34, 0x1B, 0x16, 0x15, 0xF5, 0xB0, 0xA8, 0x82, 0x23, 0x1A, 0xE6, 0xC0, 0xFA, 0xEF, 0x7D, 0x0E, 0x61, 0x21, 0xD5}},
			{2, []byte{0x01, 0xC7, 0x34, 0xEE, 0xFE, 0x09, 0xB6, 0xB7, 0x17, 0xB0, 0xBA, 0x69, 0x97, 0xCA, 0x63, 0x4A, 0xDB, 0x93, 0xE2, 0xF2, 0x27, 0xBE, 0xB7, 0x85, 0xBB, 0xB8, 0xB4, 0x47, 0x26, 0x51, 0x08, 0x45, 0x09}},
			{4, []byte{0x01, 0xB0, 0xCF, 0x0A, 0x7E, 0x6E, 0x04, 0x20, 0xD2, 0x7C, 0xDF, 0xA1, 0x1B, 0xDF, 0xAC, 0x4A, 0xA9, 0xBC, 0x77, 0x7A, 0xE4, 0xD6, 0xC0, 0x21, 0x18, 0x16, 0xBC, 0xB9, 0x1D, 0xE7, 0xC9, 0x20, 0xAD}},
			{8, []byte{0x01, 0xBB, 0x95, 0xE9, 0xB0, 0x9E, 0x7F, 0x6B, 0xC9, 0x55, 0x33, 0xD8, 0x05, 0x73, 0x9E, 0x26, 0x51, 0x0A, 0x05, 0xF9, 0x78, 0x8A, 0x86, 0xC7, 0xF8, 0x1B, 0xA8, 0xF8, 0x1E, 0x0E, 0x6C, 0x43, 0xDA}},
			{16, []byte{0x01, 0x79, 0x43, 0xB1, 0xF4, 0x52, 0x14, 0x25, 0xE1, 0x1B, 0x46, 0x1A, 0x76, 0xB9, 0xF4, 0x6B, 0x08, 0x98, 0x0F, 0xFD, 0x04, 0xCD, 0x08, 0x04, 0x97, 0xD5, 0x5A, 0x8C, 0x06, 0x3E, 0x6D, 0xCD, 0xF7}},
			{32, []byte{0x01, 0x23, 0xC4, 0xAD, 0xE3, 0xB6, 0x4A, 0x45, 0x69, 0x40, 0x88, 0xFD, 0x42, 0x73, 0x99, 0xD3, 0xC2, 0xEC, 0x12, 0x0B, 0xB0, 0xD5, 0xDF, 0x8C, 0x52, 0x12, 0xB1, 0x56, 0x2F, 0x8D, 0x82, 0x19, 0x02}},
			{64, []byte{0x01, 0xA3, 0x60, 0xBB, 0xAE, 0x9A, 0x02, 0x15, 0x19, 0x64, 0x49, 0x97, 0x1E, 0x57, 0xEB, 0x91, 0xB6, 0xC9, 0xB3, 0x97, 0x25, 0x40, 0x83, 0x24, 0xBE, 0x32, 0x5D, 0x40, 0xC2, 0x54, 0x35, 0x3F, 0xBF}},
			{128, []byte{0x01, 0x03, 0x47, 0xA3, 0xE6, 0xC1, 0x6B, 0x74, 0x34, 0x73, 0xCE, 0xCD, 0x6C, 0xAA, 0xD8, 0x13, 0x46, 0x4F, 0x8B, 0x8B, 0xD0, 0x38, 0x29, 0xF6, 0x49, 0xDD, 0x2F, 0xD3, 0xBA, 0x60, 0xD0, 0x2E, 0xCD}},
			{253, []byte{0x01, 0x78, 0xC6, 0x30, 0x34, 0x84, 0x6B, 0x2C, 0x6E, 0x67, 0x21, 0x8F, 0xBD, 0x9F, 0x58, 0x33, 0x30, 0x44, 0x2A, 0x99, 0xD7, 0x16, 0x54, 0x92, 0xFA, 0x57, 0x32, 0x02, 0x4F, 0x27, 0xFE, 0x7F, 0xFA}},
		}
	)
	verifyExpectedRootLevel(t, testExpectedRootLvl, testData, testExtraRecordLvl)
}

func verifyExpectedRootLevel(t *testing.T, expLvl byte, testData []testRecordData, extRecLvl byte) {
	tree, err := New()
	if err != nil {
		t.Fatal("Failed to create tree builder: ", err)
	}

	// Add records to the tree.
	for _, d := range testData {
		if err = tree.AddNode(d.hsh, InputHashOptionLevel(d.lvl)); err != nil {
			t.Fatal("Failed to add tree node: ", err)
		}
	}

	// Try to add one extra node. This should fail, as the tree height is already at its limit.
	if err = tree.AddNode(hash.Default.ZeroImprint(), InputHashOptionLevel(extRecLvl)); err == nil {
		t.Fatal("Should not be possible to add node as tree height is at limit.")
	}

	// Close the tree and verify expected root level.
	_, rootLvl, err := tree.Aggregate()
	if err != nil {
		t.Fatal("Failed to close tree: ", err)
	}
	if rootLvl != expLvl {
		t.Fatal("Tree root level mismatch.")
	}

}

func testTreeBuilderSHA2_512(t *testing.T, _ ...interface{}) {
	var (
		testData = [][]byte{
			{0x01, 0x09, 0xA9, 0xFE, 0x43, 0x08, 0x03, 0xD8, 0x98, 0x42, 0x73, 0x32, 0x4C, 0xF4, 0x62, 0xE4, 0x0A, 0x87, 0x5D, 0x48, 0x3D, 0xE6, 0xDD, 0x0D, 0x86, 0xBC, 0x6D, 0xFF, 0x4D, 0x27, 0xC9, 0xD8, 0x53},
			{0x01, 0xBE, 0xC8, 0x4E, 0x1F, 0x95, 0xF7, 0x29, 0xF4, 0x48, 0x23, 0x38, 0xE7, 0x81, 0x34, 0x1B, 0x16, 0x15, 0xF5, 0xB0, 0xA8, 0x82, 0x23, 0x1A, 0xE6, 0xC0, 0xFA, 0xEF, 0x7D, 0x0E, 0x61, 0x21, 0xD5},
			{0x01, 0xC7, 0x34, 0xEE, 0xFE, 0x09, 0xB6, 0xB7, 0x17, 0xB0, 0xBA, 0x69, 0x97, 0xCA, 0x63, 0x4A, 0xDB, 0x93, 0xE2, 0xF2, 0x27, 0xBE, 0xB7, 0x85, 0xBB, 0xB8, 0xB4, 0x47, 0x26, 0x51, 0x08, 0x45, 0x09},
			{0x01, 0xB0, 0xCF, 0x0A, 0x7E, 0x6E, 0x04, 0x20, 0xD2, 0x7C, 0xDF, 0xA1, 0x1B, 0xDF, 0xAC, 0x4A, 0xA9, 0xBC, 0x77, 0x7A, 0xE4, 0xD6, 0xC0, 0x21, 0x18, 0x16, 0xBC, 0xB9, 0x1D, 0xE7, 0xC9, 0x20, 0xAD},
		}
		testRootHsh = []byte{
			0x05, 0x41, 0x36, 0xe5, 0x46, 0x6a, 0x08, 0x2b, 0x35, 0x90, 0xad, 0x58, 0x87, 0x5a, 0xd2, 0xaf, 0x6a, 0x7e, 0x56, 0x04, 0x69, 0x2b, 0x0d, 0x28, 0x1c, 0xad, 0x55, 0xbe, 0xba, 0x07, 0x3c, 0xb9, 0x95, 0xf3, 0x3c, 0x6c, 0x4b, 0xf1, 0x56, 0x01, 0xa3, 0xae, 0x38, 0x7c, 0xc8, 0xde, 0x21, 0x7f, 0x55, 0xd7, 0xe5, 0x93, 0x50, 0xcd, 0x9e, 0xaf, 0x96, 0x35, 0x9b, 0x30, 0xf3, 0x80, 0xa2, 0xd2, 0x23,
		}
	)

	tree, err := New(
		TreeOptAlgorithm(hash.SHA2_512),
	)
	if err != nil {
		t.Fatal("Failed to create tree builder: ", err)
	}

	for i, hsh := range testData {
		if err := tree.AddNode(hsh); err != nil {
			t.Fatal("Failed to add tree node: ", err)
		}

		nodeIndex, err := tree.Count()
		if err != nil {
			t.Fatal("Failed to get leaf count: ", err)
		}

		if i != nodeIndex-1 {
			t.Error("Position mismatch.")
		}
	}

	rootHsh, _, err := tree.Aggregate()
	if err != nil {
		t.Fatal("Failed to close tree: ", err)
	}
	if !hash.Equal(testRootHsh, rootHsh) {
		t.Fatal("Root hash mismatch.")
	}
}

func testTreeBuilderSHA1(t *testing.T, _ ...interface{}) {

	if _, err := New(TreeOptAlgorithm(hash.SHA1)); err == nil {
		t.Fatal("Must fail with untrusted algorithm.")
	}

}

func testTreeBuilderUserContext(t *testing.T, _ ...interface{}) {

	var (
		testData = []struct {
			usrCtx string
			hsh    []byte
		}{
			{"Hsh1", []byte{0x01, 0x09, 0xA9, 0xFE, 0x43, 0x08, 0x03, 0xD8, 0x98, 0x42, 0x73, 0x32, 0x4C, 0xF4, 0x62, 0xE4, 0x0A, 0x87, 0x5D, 0x48, 0x3D, 0xE6, 0xDD, 0x0D, 0x86, 0xBC, 0x6D, 0xFF, 0x4D, 0x27, 0xC9, 0xD8, 0x53}},
			{"Hsh2", []byte{0x01, 0xBE, 0xC8, 0x4E, 0x1F, 0x95, 0xF7, 0x29, 0xF4, 0x48, 0x23, 0x38, 0xE7, 0x81, 0x34, 0x1B, 0x16, 0x15, 0xF5, 0xB0, 0xA8, 0x82, 0x23, 0x1A, 0xE6, 0xC0, 0xFA, 0xEF, 0x7D, 0x0E, 0x61, 0x21, 0xD5}},
			{"Hsh3", []byte{0x01, 0xC7, 0x34, 0xEE, 0xFE, 0x09, 0xB6, 0xB7, 0x17, 0xB0, 0xBA, 0x69, 0x97, 0xCA, 0x63, 0x4A, 0xDB, 0x93, 0xE2, 0xF2, 0x27, 0xBE, 0xB7, 0x85, 0xBB, 0xB8, 0xB4, 0x47, 0x26, 0x51, 0x08, 0x45, 0x09}},
			{"Hsh4", []byte{0x01, 0xB0, 0xCF, 0x0A, 0x7E, 0x6E, 0x04, 0x20, 0xD2, 0x7C, 0xDF, 0xA1, 0x1B, 0xDF, 0xAC, 0x4A, 0xA9, 0xBC, 0x77, 0x7A, 0xE4, 0xD6, 0xC0, 0x21, 0x18, 0x16, 0xBC, 0xB9, 0x1D, 0xE7, 0xC9, 0x20, 0xAD}},
		}
	)

	tree, err := New()
	if err != nil {
		t.Fatal("Failed to create tree builder: ", err)
	}

	for _, d := range testData {
		if err := tree.AddNode(d.hsh, InputHashOptionUserContext(d.usrCtx)); err != nil {
			t.Fatal("Failed to add tree node: ", err)
		}
	}

	if _, _, err := tree.Aggregate(); err != nil {
		t.Fatal("Failed to close tree: ", err)
	}

	leafs, err := tree.Leafs()
	if err != nil {
		t.Fatal("Failed to get tree leafs: ", err)
	}
	for i, l := range leafs {
		usrCtx, err := l.UserCtx()
		if err != nil {
			t.Fatal("Failed to get leaf user context: ", err)
		}
		if usrCtx.(string) != testData[i].usrCtx {
			t.Fatal("User context mismatch.")
		}
	}
}

func testTreeBuilderListener(t *testing.T, _ ...interface{}) {

	var (
		testData = []struct {
			expected []int
			hsh      []byte
		}{
			{[]int{0, 1, 5}, []byte{0x01, 0x09, 0xA9, 0xFE, 0x43, 0x08, 0x03, 0xD8, 0x98, 0x42, 0x73, 0x32, 0x4C, 0xF4, 0x62, 0xE4, 0x0A, 0x87, 0x5D, 0x48, 0x3D, 0xE6, 0xDD, 0x0D, 0x86, 0xBC, 0x6D, 0xFF, 0x4D, 0x27, 0xC9, 0xD8, 0x53}},
			{[]int{1, 0, 5}, []byte{0x01, 0xBE, 0xC8, 0x4E, 0x1F, 0x95, 0xF7, 0x29, 0xF4, 0x48, 0x23, 0x38, 0xE7, 0x81, 0x34, 0x1B, 0x16, 0x15, 0xF5, 0xB0, 0xA8, 0x82, 0x23, 0x1A, 0xE6, 0xC0, 0xFA, 0xEF, 0x7D, 0x0E, 0x61, 0x21, 0xD5}},
			{[]int{3, 4, 2}, []byte{0x01, 0xC7, 0x34, 0xEE, 0xFE, 0x09, 0xB6, 0xB7, 0x17, 0xB0, 0xBA, 0x69, 0x97, 0xCA, 0x63, 0x4A, 0xDB, 0x93, 0xE2, 0xF2, 0x27, 0xBE, 0xB7, 0x85, 0xBB, 0xB8, 0xB4, 0x47, 0x26, 0x51, 0x08, 0x45, 0x09}},
			{[]int{4, 3, 2}, []byte{0x01, 0xB0, 0xCF, 0x0A, 0x7E, 0x6E, 0x04, 0x20, 0xD2, 0x7C, 0xDF, 0xA1, 0x1B, 0xDF, 0xAC, 0x4A, 0xA9, 0xBC, 0x77, 0x7A, 0xE4, 0xD6, 0xC0, 0x21, 0x18, 0x16, 0xBC, 0xB9, 0x1D, 0xE7, 0xC9, 0x20, 0xAD}},
		}

		testListener mock.TreeBuilderListenerMock
		testExpected = []mock.TBLMEntry{
			{ValType: mock.TBLMDocumentHash, Value: utils.StringToBin("0109a9fe430803d8984273324cf462e40a875d483de6dd0d86bc6dff4d27c9d853")},
			{ValType: mock.TBLMDocumentHash, Value: utils.StringToBin("01bec84e1f95f729f4482338e781341b1615f5b0a882231ae6c0faef7d0e6121d5")},
			{ValType: mock.TBLMIntAggrHash, Value: utils.StringToBin("0119e76a98acb020966a337063effe8c9ba329887a9279fa19aea6ad9b73c74d62")},
			{ValType: mock.TBLMDocumentHash, Value: utils.StringToBin("01c734eefe09b6b717b0ba6997ca634adb93e2f227beb785bbb8b4472651084509")},
			{ValType: mock.TBLMDocumentHash, Value: utils.StringToBin("01b0cf0a7e6e0420d27cdfa11bdfac4aa9bc777ae4d6c0211816bcb91de7c920ad")},
			{ValType: mock.TBLMIntAggrHash, Value: utils.StringToBin("01fe982d00d7622541d5bb454019bf63e8ee1d3789119903e6b80fa93f83e1a361")},
			{ValType: mock.TBLMIntAggrHash, Value: utils.StringToBin("0164597a5984e8682b5d6e3b15dd731ddfeb8e728e608b6b1fc91a1f01467aa2c4")},
		}
	)

	tree, err := New(
		TreeOptRecordListener(&testListener),
		TreeOptAggregateListener(&testListener),
	)
	if err != nil {
		t.Fatal("Failed to create tree builder: ", err)
	}

	for _, d := range testData {
		if err := tree.AddNode(d.hsh, InputHashOptionUserContext(d.expected)); err != nil {
			t.Fatal("Failed to add tree node: ", err)
		}
	}

	root, _, err := tree.Aggregate()
	if err != nil {
		t.Fatal("Failed to close tree: ", err)
	}
	if !hash.Equal(root, testExpected[len(testExpected)-1].Value) {
		t.Fatal("Root hash mismatch.")
	}
	if testExpected[len(testExpected)-1].ValType != testListener.Entries[len(testExpected)-1].ValType {
		t.Fatal("Listener root type mismatch.")
	}
	if !hash.Equal(testExpected[len(testExpected)-1].Value, testListener.Entries[len(testExpected)-1].Value) {
		t.Fatal("Listener root hash mismatch.")
	}

	leafs, err := tree.Leafs()
	if err != nil {
		t.Fatal("Failed to get tree leafs: ", err)
	}
	for _, l := range leafs {
		expected, err := l.UserCtx()
		if err != nil {
			t.Fatal("Failed to get leaf user context: ", err)
		}
		chain, err := l.AggregationChain()
		if err != nil {
			t.Fatal("Failed to get leaf aggregation hash chain: ", err)
		}

		log.Debug(chain)

		docHash, err := chain.InputHash()
		if err != nil {
			t.Fatal("Failed to get chain input hash: ", err)
		}
		if !hash.Equal(docHash, testExpected[expected.([]int)[0]].Value) {
			t.Fatal("Document hash mismatch.")
		}
		if testExpected[expected.([]int)[0]].ValType != testListener.Entries[expected.([]int)[0]].ValType {
			t.Fatal("Listener root type mismatch.")
		}
		if !hash.Equal(testExpected[expected.([]int)[0]].Value, testListener.Entries[expected.([]int)[0]].Value) {
			t.Fatal("Listener root hash mismatch.")
		}

		links, err := chain.ChainLinks()
		if err != nil {
			t.Fatal("Failed to get chain links: ", err)
		}
		if len(links) != len(expected.([]int))-1 {
			t.Fatal("Nof links mismatch.")
		}

		for i, l := range links {
			sibling, err := l.SiblingHash()
			if err != nil {
				t.Fatal("Failed to get sibling: ", err)
			}
			if !hash.Equal(sibling, testExpected[expected.([]int)[i+1]].Value) {
				t.Fatal("Sibling hash mismatch.")
			}
			if testExpected[expected.([]int)[i+1]].ValType != testListener.Entries[expected.([]int)[i+1]].ValType {
				t.Fatal("Listener root type mismatch.")
			}
			if !hash.Equal(testExpected[expected.([]int)[i+1]].Value, testListener.Entries[expected.([]int)[i+1]].Value) {
				t.Fatal("Sibling hash mismatch.")
			}
		}
	}
}

func testTreeBuilderListenerOnlyAggrListener(t *testing.T, _ ...interface{}) {

	var (
		testData = [][]byte{
			{0x01, 0x09, 0xA9, 0xFE, 0x43, 0x08, 0x03, 0xD8, 0x98, 0x42, 0x73, 0x32, 0x4C, 0xF4, 0x62, 0xE4, 0x0A, 0x87, 0x5D, 0x48, 0x3D, 0xE6, 0xDD, 0x0D, 0x86, 0xBC, 0x6D, 0xFF, 0x4D, 0x27, 0xC9, 0xD8, 0x53},
			{0x01, 0xBE, 0xC8, 0x4E, 0x1F, 0x95, 0xF7, 0x29, 0xF4, 0x48, 0x23, 0x38, 0xE7, 0x81, 0x34, 0x1B, 0x16, 0x15, 0xF5, 0xB0, 0xA8, 0x82, 0x23, 0x1A, 0xE6, 0xC0, 0xFA, 0xEF, 0x7D, 0x0E, 0x61, 0x21, 0xD5},
			{0x01, 0xC7, 0x34, 0xEE, 0xFE, 0x09, 0xB6, 0xB7, 0x17, 0xB0, 0xBA, 0x69, 0x97, 0xCA, 0x63, 0x4A, 0xDB, 0x93, 0xE2, 0xF2, 0x27, 0xBE, 0xB7, 0x85, 0xBB, 0xB8, 0xB4, 0x47, 0x26, 0x51, 0x08, 0x45, 0x09},
			{0x01, 0xB0, 0xCF, 0x0A, 0x7E, 0x6E, 0x04, 0x20, 0xD2, 0x7C, 0xDF, 0xA1, 0x1B, 0xDF, 0xAC, 0x4A, 0xA9, 0xBC, 0x77, 0x7A, 0xE4, 0xD6, 0xC0, 0x21, 0x18, 0x16, 0xBC, 0xB9, 0x1D, 0xE7, 0xC9, 0x20, 0xAD},
		}

		testListener mock.TreeBuilderListenerMock
		testExpected = []mock.TBLMEntry{
			{ValType: mock.TBLMIntAggrHash, Value: utils.StringToBin("0119e76a98acb020966a337063effe8c9ba329887a9279fa19aea6ad9b73c74d62")},
			{ValType: mock.TBLMIntAggrHash, Value: utils.StringToBin("01fe982d00d7622541d5bb454019bf63e8ee1d3789119903e6b80fa93f83e1a361")},
			{ValType: mock.TBLMIntAggrHash, Value: utils.StringToBin("0164597a5984e8682b5d6e3b15dd731ddfeb8e728e608b6b1fc91a1f01467aa2c4")},
		}
	)

	tree, err := New(
		TreeOptAggregateListener(&testListener),
	)
	if err != nil {
		t.Fatal("Failed to create tree builder: ", err)
	}

	for _, h := range testData {
		if err := tree.AddNode(h); err != nil {
			t.Fatal("Failed to add tree node: ", err)
		}
	}

	root, _, err := tree.Aggregate()
	if err != nil {
		t.Fatal("Failed to close tree: ", err)
	}
	if !hash.Equal(root, testExpected[len(testExpected)-1].Value) {
		t.Fatal("Root hash mismatch.")
	}
	if testExpected[len(testExpected)-1].ValType != testListener.Entries[len(testExpected)-1].ValType {
		t.Fatal("Listener root type mismatch.")
	}
	if !hash.Equal(testExpected[len(testExpected)-1].Value, testListener.Entries[len(testExpected)-1].Value) {
		t.Fatal("Listener root hash mismatch.")
	}

	if len(testExpected) != len(testListener.Entries) {
		t.Fatal("Nof expected entries mismatch.")
	}
	for i, e := range testListener.Entries {
		if testExpected[i].ValType != e.ValType {
			t.Fatal("Expected entry value type mismatch.")
		}
		if !hash.Equal(testExpected[i].Value, e.Value) {
			t.Fatal("Expected entry value mismatch.")
		}
		if testExpected[i].ValType != testListener.Entries[i].ValType {
			t.Fatal("Listener root type mismatch.")
		}
		if !hash.Equal(testExpected[i].Value, testListener.Entries[i].Value) {
			t.Fatal("Sibling hash mismatch.")
		}
	}
}

func testTreeBuilderListenerWithMetadata(t *testing.T, _ ...interface{}) {

	var (
		testData = []struct {
			client   string
			expected []int
			hsh      []byte
		}{
			{"Client1", []int{0, 1, 5, 13}, []byte{0x01, 0x09, 0xA9, 0xFE, 0x43, 0x08, 0x03, 0xD8, 0x98, 0x42, 0x73, 0x32, 0x4C, 0xF4, 0x62, 0xE4, 0x0A, 0x87, 0x5D, 0x48, 0x3D, 0xE6, 0xDD, 0x0D, 0x86, 0xBC, 0x6D, 0xFF, 0x4D, 0x27, 0xC9, 0xD8, 0x53}},
			{"Client2", []int{3, 4, 2, 13}, []byte{0x01, 0xBE, 0xC8, 0x4E, 0x1F, 0x95, 0xF7, 0x29, 0xF4, 0x48, 0x23, 0x38, 0xE7, 0x81, 0x34, 0x1B, 0x16, 0x15, 0xF5, 0xB0, 0xA8, 0x82, 0x23, 0x1A, 0xE6, 0xC0, 0xFA, 0xEF, 0x7D, 0x0E, 0x61, 0x21, 0xD5}},
			{"Client3", []int{7, 8, 12, 6}, []byte{0x01, 0xC7, 0x34, 0xEE, 0xFE, 0x09, 0xB6, 0xB7, 0x17, 0xB0, 0xBA, 0x69, 0x97, 0xCA, 0x63, 0x4A, 0xDB, 0x93, 0xE2, 0xF2, 0x27, 0xBE, 0xB7, 0x85, 0xBB, 0xB8, 0xB4, 0x47, 0x26, 0x51, 0x08, 0x45, 0x09}},
			{"Client4", []int{10, 11, 9, 6}, []byte{0x01, 0xB0, 0xCF, 0x0A, 0x7E, 0x6E, 0x04, 0x20, 0xD2, 0x7C, 0xDF, 0xA1, 0x1B, 0xDF, 0xAC, 0x4A, 0xA9, 0xBC, 0x77, 0x7A, 0xE4, 0xD6, 0xC0, 0x21, 0x18, 0x16, 0xBC, 0xB9, 0x1D, 0xE7, 0xC9, 0x20, 0xAD}},
		}

		testListener mock.TreeBuilderListenerMock
		testExpected = []mock.TBLMEntry{
			{ValType: mock.TBLMDocumentHash, Value: utils.StringToBin("0109a9fe430803d8984273324cf462e40a875d483de6dd0d86bc6dff4d27c9d853")},
			{ValType: mock.TBLMMetadataRec, Value: utils.StringToBin("7e0201010108436c69656e743100")},
			{ValType: mock.TBLMIntAggrHash, Value: utils.StringToBin("0130a35b29402a76b7c36204e2702335e3fce9aca341b8ffd23149b9f2b9dd02ca")},
			{ValType: mock.TBLMDocumentHash, Value: utils.StringToBin("01bec84e1f95f729f4482338e781341b1615f5b0a882231ae6c0faef7d0e6121d5")},
			{ValType: mock.TBLMMetadataRec, Value: utils.StringToBin("7e0201010108436c69656e743200")},
			{ValType: mock.TBLMIntAggrHash, Value: utils.StringToBin("014896a68024464d3123e8c33b5fef37bcac3faf2a09228d713f1c13a5b1973712")},
			{ValType: mock.TBLMIntAggrHash, Value: utils.StringToBin("01ec76e59f13c6773e8d5805cec1cb3344d15e5ad14bbde312299910cf8aad38b6")},
			{ValType: mock.TBLMDocumentHash, Value: utils.StringToBin("01c734eefe09b6b717b0ba6997ca634adb93e2f227beb785bbb8b4472651084509")},
			{ValType: mock.TBLMMetadataRec, Value: utils.StringToBin("7e0201010108436c69656e743300")},
			{ValType: mock.TBLMIntAggrHash, Value: utils.StringToBin("01c5ad6232ed538f70dbae589d8593fcae259d8e1e0588a587054cadc3fe0308e9")},
			{ValType: mock.TBLMDocumentHash, Value: utils.StringToBin("01b0cf0a7e6e0420d27cdfa11bdfac4aa9bc777ae4d6c0211816bcb91de7c920ad")},
			{ValType: mock.TBLMMetadataRec, Value: utils.StringToBin("7e0201010108436c69656e743400")},
			{ValType: mock.TBLMIntAggrHash, Value: utils.StringToBin("01971ab23ab994161c183ba99a087da1efd3918579538419ddaf6542cbc57f6811")},
			{ValType: mock.TBLMIntAggrHash, Value: utils.StringToBin("017d86d14de786448ae01281b9fda07520bccfe365a82d0c6f818719f3d62bd0ae")},
			{ValType: mock.TBLMIntAggrHash, Value: utils.StringToBin("0160275e042689c3ac73cebd7ee784bb26ac32a61934af3fc23338729722ef518b")},
		}
	)

	tree, err := New(
		TreeOptRecordListener(&testListener),
		TreeOptMetadataListener(&testListener),
		TreeOptAggregateListener(&testListener),
	)
	if err != nil {
		t.Fatal("Failed to create tree builder: ", err)
	}

	for _, d := range testData {
		md, err := pdu.NewMetaData(d.client)
		if err != nil {
			t.Fatal("Failed to create metadata: ", err)
		}

		if err = tree.AddNode(d.hsh, InputHashOptionMetadata(md), InputHashOptionUserContext(d.expected)); err != nil {
			t.Fatal("Failed to add tree node: ", err)
		}
	}

	root, _, err := tree.Aggregate()
	if err != nil {
		t.Fatal("Failed to close tree: ", err)
	}
	if !hash.Equal(root, testExpected[len(testExpected)-1].Value) {
		t.Fatal("Root hash mismatch.")
	}
	if testExpected[len(testExpected)-1].ValType != testListener.Entries[len(testExpected)-1].ValType {
		t.Fatal("Listener root type mismatch.")
	}
	if !hash.Equal(testExpected[len(testExpected)-1].Value, testListener.Entries[len(testExpected)-1].Value) {
		t.Fatal("Listener root hash mismatch.")
	}

	leafs, err := tree.Leafs()
	if err != nil {
		t.Fatal("Failed to get tree leafs: ", err)
	}
	for _, l := range leafs {
		expected, err := l.UserCtx()
		if err != nil {
			t.Fatal("Failed to get leaf user context: ", err)
		}
		chain, err := l.AggregationChain()
		if err != nil {
			t.Fatal("Failed to get leaf aggregation hash chain: ", err)
		}

		docHash, err := chain.InputHash()
		if err != nil {
			t.Fatal("Failed to get chain input hash: ", err)
		}
		if !hash.Equal(docHash, testExpected[expected.([]int)[0]].Value) {
			t.Fatal("Document hash mismatch.")
		}
		if testExpected[expected.([]int)[0]].ValType != testListener.Entries[expected.([]int)[0]].ValType {
			t.Fatal("Listener root type mismatch.")
		}
		if !hash.Equal(testExpected[expected.([]int)[0]].Value, testListener.Entries[expected.([]int)[0]].Value) {
			t.Fatal("Listener root hash mismatch.")
		}

		links, err := chain.ChainLinks()
		if err != nil {
			t.Fatal("Failed to get chain links: ", err)
		}
		if len(links) != len(expected.([]int))-1 {
			t.Fatal("Nof links mismatch.")
		}

		for i, l := range links {
			var (
				expEntry     = testExpected[expected.([]int)[i+1]]
				lstEntry     = testListener.Entries[expected.([]int)[i+1]]
				siblingValue []byte
			)

			if i != 0 {
				if expEntry.ValType != mock.TBLMIntAggrHash {
					t.Fatal("Sibling type mismatch.")
				}

				siblingValue, err = l.SiblingHash()
				if err != nil {
					t.Fatal("Failed to get sibling hash: ", err)
				}
			} else {
				if expEntry.ValType != mock.TBLMMetadataRec {
					t.Fatal("Sibling type mismatch.")
				}

				meta, err := l.MetaData()
				if err != nil {
					t.Fatal("Failed to get sibling metadata: ", err)
				}
				tlv, err := meta.EncodeToTlv()
				if err != nil {
					t.Fatal("Failed to encode metadata: ", err)
				}
				siblingValue = tlv.Value()
			}

			if !hash.Equal(siblingValue, expEntry.Value) {
				t.Fatal("Sibling hash mismatch.")
			}
			if expEntry.ValType != lstEntry.ValType {
				t.Fatal("Listener root type mismatch.")
			}
			if !hash.Equal(expEntry.Value, lstEntry.Value) {
				t.Fatal("Sibling hash mismatch.")
			}
		}
	}
}

func testTreeBuilderListenerVerifyAggrHashLevel(t *testing.T, _ ...interface{}) {

	var (
		testData = []struct {
			lvl byte
			hsh []byte
		}{
			{0x00, []byte{0x01, 0x09, 0xA9, 0xFE, 0x43, 0x08, 0x03, 0xD8, 0x98, 0x42, 0x73, 0x32, 0x4C, 0xF4, 0x62, 0xE4, 0x0A, 0x87, 0x5D, 0x48, 0x3D, 0xE6, 0xDD, 0x0D, 0x86, 0xBC, 0x6D, 0xFF, 0x4D, 0x27, 0xC9, 0xD8, 0x53}},
			{0x01, []byte{0x01, 0xBE, 0xC8, 0x4E, 0x1F, 0x95, 0xF7, 0x29, 0xF4, 0x48, 0x23, 0x38, 0xE7, 0x81, 0x34, 0x1B, 0x16, 0x15, 0xF5, 0xB0, 0xA8, 0x82, 0x23, 0x1A, 0xE6, 0xC0, 0xFA, 0xEF, 0x7D, 0x0E, 0x61, 0x21, 0xD5}},
			{0x02, []byte{0x01, 0xC7, 0x34, 0xEE, 0xFE, 0x09, 0xB6, 0xB7, 0x17, 0xB0, 0xBA, 0x69, 0x97, 0xCA, 0x63, 0x4A, 0xDB, 0x93, 0xE2, 0xF2, 0x27, 0xBE, 0xB7, 0x85, 0xBB, 0xB8, 0xB4, 0x47, 0x26, 0x51, 0x08, 0x45, 0x09}},
			{0x04, []byte{0x01, 0xB0, 0xCF, 0x0A, 0x7E, 0x6E, 0x04, 0x20, 0xD2, 0x7C, 0xDF, 0xA1, 0x1B, 0xDF, 0xAC, 0x4A, 0xA9, 0xBC, 0x77, 0x7A, 0xE4, 0xD6, 0xC0, 0x21, 0x18, 0x16, 0xBC, 0xB9, 0x1D, 0xE7, 0xC9, 0x20, 0xAD}},
			{0x08, []byte{0x01, 0xBB, 0x95, 0xE9, 0xB0, 0x9E, 0x7F, 0x6B, 0xC9, 0x55, 0x33, 0xD8, 0x05, 0x73, 0x9E, 0x26, 0x51, 0x0A, 0x05, 0xF9, 0x78, 0x8A, 0x86, 0xC7, 0xF8, 0x1B, 0xA8, 0xF8, 0x1E, 0x0E, 0x6C, 0x43, 0xDA}},
			{0x10, []byte{0x01, 0x79, 0x43, 0xB1, 0xF4, 0x52, 0x14, 0x25, 0xE1, 0x1B, 0x46, 0x1A, 0x76, 0xB9, 0xF4, 0x6B, 0x08, 0x98, 0x0F, 0xFD, 0x04, 0xCD, 0x08, 0x04, 0x97, 0xD5, 0x5A, 0x8C, 0x06, 0x3E, 0x6D, 0xCD, 0xF7}},
			{0x03, []byte{0x01, 0x23, 0xC4, 0xAD, 0xE3, 0xB6, 0x4A, 0x45, 0x69, 0x40, 0x88, 0xFD, 0x42, 0x73, 0x99, 0xD3, 0xC2, 0xEC, 0x12, 0x0B, 0xB0, 0xD5, 0xDF, 0x8C, 0x52, 0x12, 0xB1, 0x56, 0x2F, 0x8D, 0x82, 0x19, 0x02}},
			{0x05, []byte{0x01, 0xA3, 0x60, 0xBB, 0xAE, 0x9A, 0x02, 0x15, 0x19, 0x64, 0x49, 0x97, 0x1E, 0x57, 0xEB, 0x91, 0xB6, 0xC9, 0xB3, 0x97, 0x25, 0x40, 0x83, 0x24, 0xBE, 0x32, 0x5D, 0x40, 0xC2, 0x54, 0x35, 0x3F, 0xBF}},
			{0x07, []byte{0x01, 0x03, 0x47, 0xA3, 0xE6, 0xC1, 0x6B, 0x74, 0x34, 0x73, 0xCE, 0xCD, 0x6C, 0xAA, 0xD8, 0x13, 0x46, 0x4F, 0x8B, 0x8B, 0xD0, 0x38, 0x29, 0xF6, 0x49, 0xDD, 0x2F, 0xD3, 0xBA, 0x60, 0xD0, 0x2E, 0xCD}},
			{0x0f, []byte{0x01, 0x78, 0xC6, 0x30, 0x34, 0x84, 0x6B, 0x2C, 0x6E, 0x67, 0x21, 0x8F, 0xBD, 0x9F, 0x58, 0x33, 0x30, 0x44, 0x2A, 0x99, 0xD7, 0x16, 0x54, 0x92, 0xFA, 0x57, 0x32, 0x02, 0x4F, 0x27, 0xFE, 0x7F, 0xFA}},
		}

		testListener mock.TreeBuilderListenerMock
		testExpected = []mock.TBLMEntry{
			{ValType: mock.TBLMDocumentHash, Value: utils.StringToBin("0109a9fe430803d8984273324cf462e40a875d483de6dd0d86bc6dff4d27c9d853"), Level: 0},
			{ValType: mock.TBLMDocumentHash, Value: utils.StringToBin("01bec84e1f95f729f4482338e781341b1615f5b0a882231ae6c0faef7d0e6121d5"), Level: 1},
			{ValType: mock.TBLMIntAggrHash, Value: utils.StringToBin("019aa3a90cca35bf036cdb74c2b8c718f6c297c4a72d988e2d10e9f1ba502a313f"), Level: 2},
			{ValType: mock.TBLMDocumentHash, Value: utils.StringToBin("01c734eefe09b6b717b0ba6997ca634adb93e2f227beb785bbb8b4472651084509"), Level: 2},
			{ValType: mock.TBLMDocumentHash, Value: utils.StringToBin("01b0cf0a7e6e0420d27cdfa11bdfac4aa9bc777ae4d6c0211816bcb91de7c920ad"), Level: 4},
			{ValType: mock.TBLMIntAggrHash, Value: utils.StringToBin("01560177c409ec2f2b98657b89f4aaec9eed2bd2877bc22216f20adcbed0bde00e"), Level: 5},
			{ValType: mock.TBLMIntAggrHash, Value: utils.StringToBin("014128e3a725a9714611952d5002b9c374f06b9ab7c84546a69203765180610914"), Level: 6},
			{ValType: mock.TBLMDocumentHash, Value: utils.StringToBin("01bb95e9b09e7f6bc95533d805739e26510a05f9788a86c7f81ba8f81e0e6c43da"), Level: 8},
			{ValType: mock.TBLMDocumentHash, Value: utils.StringToBin("017943b1f4521425e11b461a76b9f46b08980ffd04cd080497d55a8c063e6dcdf7"), Level: 16},
			{ValType: mock.TBLMIntAggrHash, Value: utils.StringToBin("01aa3c383c7757ad0e8a964d652eb21bd9d47f2fa0675231d3e5e36d1dfc124dce"), Level: 17},
			{ValType: mock.TBLMDocumentHash, Value: utils.StringToBin("0123c4ade3b64a45694088fd427399d3c2ec120bb0d5df8c5212b1562f8d821902"), Level: 3},
			{ValType: mock.TBLMDocumentHash, Value: utils.StringToBin("01a360bbae9a0215196449971e57eb91b6c9b39725408324be325d40c254353fbf"), Level: 5},
			{ValType: mock.TBLMIntAggrHash, Value: utils.StringToBin("01dea3bc26eb486a4437dd382880d29811965d6ce78ab9fdf013add54411fe5fb9"), Level: 6},
			{ValType: mock.TBLMIntAggrHash, Value: utils.StringToBin("0106f8441e07bcdb35fc312e075e8517c592539231081bd199557f32370aafc541"), Level: 18},
			{ValType: mock.TBLMIntAggrHash, Value: utils.StringToBin("019f2e6ac7ec185a5a795206acde2fe0590aeb05c3e70073d6e74c675362b4e4fd"), Level: 19},
			{ValType: mock.TBLMDocumentHash, Value: utils.StringToBin("010347a3e6c16b743473cecd6caad813464f8b8bd03829f649dd2fd3ba60d02ecd"), Level: 7},
			{ValType: mock.TBLMDocumentHash, Value: utils.StringToBin("0178c63034846b2c6e67218fbd9f583330442a99d7165492fa5732024f27fe7ffa"), Level: 15},
			{ValType: mock.TBLMIntAggrHash, Value: utils.StringToBin("017c95220f7e28495b85ace7ccf5d2d0d90a335be6cbdd914297e7fd38bfc7efb5"), Level: 16},
			{ValType: mock.TBLMIntAggrHash, Value: utils.StringToBin("019caf55969ab4f930e6422025f70e84aa49542f23b8b19279a402f36f4c048687"), Level: 20},
		}
	)

	// Construct new tree-builder.
	tree, err := New(
		TreeOptRecordListener(&testListener),
		TreeOptAggregateListener(&testListener),
	)
	if err != nil {
		t.Fatal("Failed to create tree builder: ", err)
	}
	// Add leafs to the tree.
	for _, d := range testData {
		if err = tree.AddNode(d.hsh, InputHashOptionLevel(d.lvl)); err != nil {
			t.Fatal("Failed to add tree node: ", err)
		}
	}
	// Calculate the root values and verify with expected.
	rootHsh, rootLvl, err := tree.Aggregate()
	if err != nil {
		t.Fatal("Failed to close tree: ", err)
	}
	if !hash.Equal(rootHsh, testExpected[len(testExpected)-1].Value) {
		t.Fatal("Root hash mismatch.")
	}
	if rootLvl != testExpected[len(testExpected)-1].Level {
		t.Fatal("Root level mismatch.")
	}
	// Verify listener entries.
	if len(testExpected) != len(testListener.Entries) {
		t.Fatal("Listener entries count mismatch.")
	}
	for i := 0; i < len(testExpected); i++ {
		if !testExpected[i].Equals(&testListener.Entries[i]) {
			t.Fatalf("Listener entry[%d] mismatch.", i)
		}
	}
}

type failingListener struct{}

func (m *failingListener) TreeRecordHash(_ hash.Imprint, _ byte) error {
	return stderr.New("some error")
}
func (m *failingListener) TreeAggregateHash(_ hash.Imprint, _ byte) error {
	return errors.New(errors.KsiNotImplemented)
}

func testTreeBuilderFailingListenerOnRecordHash(t *testing.T, _ ...interface{}) {

	var (
		testData = [][]byte{
			{0x01, 0x09, 0xA9, 0xFE, 0x43, 0x08, 0x03, 0xD8, 0x98, 0x42, 0x73, 0x32, 0x4C, 0xF4, 0x62, 0xE4, 0x0A, 0x87, 0x5D, 0x48, 0x3D, 0xE6, 0xDD, 0x0D, 0x86, 0xBC, 0x6D, 0xFF, 0x4D, 0x27, 0xC9, 0xD8, 0x53},
			{0x01, 0xBE, 0xC8, 0x4E, 0x1F, 0x95, 0xF7, 0x29, 0xF4, 0x48, 0x23, 0x38, 0xE7, 0x81, 0x34, 0x1B, 0x16, 0x15, 0xF5, 0xB0, 0xA8, 0x82, 0x23, 0x1A, 0xE6, 0xC0, 0xFA, 0xEF, 0x7D, 0x0E, 0x61, 0x21, 0xD5},
			{0x01, 0xC7, 0x34, 0xEE, 0xFE, 0x09, 0xB6, 0xB7, 0x17, 0xB0, 0xBA, 0x69, 0x97, 0xCA, 0x63, 0x4A, 0xDB, 0x93, 0xE2, 0xF2, 0x27, 0xBE, 0xB7, 0x85, 0xBB, 0xB8, 0xB4, 0x47, 0x26, 0x51, 0x08, 0x45, 0x09},
			{0x01, 0xB0, 0xCF, 0x0A, 0x7E, 0x6E, 0x04, 0x20, 0xD2, 0x7C, 0xDF, 0xA1, 0x1B, 0xDF, 0xAC, 0x4A, 0xA9, 0xBC, 0x77, 0x7A, 0xE4, 0xD6, 0xC0, 0x21, 0x18, 0x16, 0xBC, 0xB9, 0x1D, 0xE7, 0xC9, 0x20, 0xAD},
		}
		testListener failingListener
	)

	tree, err := New(
		TreeOptRecordListener(&testListener),
	)
	if err != nil {
		t.Fatal("Failed to create tree builder: ", err)
	}

	for _, h := range testData {
		err := tree.AddNode(h)
		if err == nil {
			t.Fatal("Must return an error.")
		}
		if _, ok := err.(*errors.KsiError); !ok {
			t.Fatal("Error must be wrapped into KSI error.")
		}
		if err.(*errors.KsiError).Code() != errors.KsiExternalError {
			t.Fatal("Wrapped error code mismatch.")
		}
	}
}

func testTreeBuilderFailingListenerOnIntAggrHash(t *testing.T, _ ...interface{}) {

	var (
		testData = [][]byte{
			{0x01, 0x09, 0xA9, 0xFE, 0x43, 0x08, 0x03, 0xD8, 0x98, 0x42, 0x73, 0x32, 0x4C, 0xF4, 0x62, 0xE4, 0x0A, 0x87, 0x5D, 0x48, 0x3D, 0xE6, 0xDD, 0x0D, 0x86, 0xBC, 0x6D, 0xFF, 0x4D, 0x27, 0xC9, 0xD8, 0x53},
			{0x01, 0xBE, 0xC8, 0x4E, 0x1F, 0x95, 0xF7, 0x29, 0xF4, 0x48, 0x23, 0x38, 0xE7, 0x81, 0x34, 0x1B, 0x16, 0x15, 0xF5, 0xB0, 0xA8, 0x82, 0x23, 0x1A, 0xE6, 0xC0, 0xFA, 0xEF, 0x7D, 0x0E, 0x61, 0x21, 0xD5},
			{0x01, 0xC7, 0x34, 0xEE, 0xFE, 0x09, 0xB6, 0xB7, 0x17, 0xB0, 0xBA, 0x69, 0x97, 0xCA, 0x63, 0x4A, 0xDB, 0x93, 0xE2, 0xF2, 0x27, 0xBE, 0xB7, 0x85, 0xBB, 0xB8, 0xB4, 0x47, 0x26, 0x51, 0x08, 0x45, 0x09},
			{0x01, 0xB0, 0xCF, 0x0A, 0x7E, 0x6E, 0x04, 0x20, 0xD2, 0x7C, 0xDF, 0xA1, 0x1B, 0xDF, 0xAC, 0x4A, 0xA9, 0xBC, 0x77, 0x7A, 0xE4, 0xD6, 0xC0, 0x21, 0x18, 0x16, 0xBC, 0xB9, 0x1D, 0xE7, 0xC9, 0x20, 0xAD},
		}
		testListener failingListener
	)

	tree, err := New(
		TreeOptAggregateListener(&testListener),
	)
	if err != nil {
		t.Fatal("Failed to create tree builder: ", err)
	}

	for _, h := range testData {
		err := tree.AddNode(h)
		nof, countErr := tree.Count()
		if countErr != nil {
			t.Fatal("Unable to get leaf count: ", err)
		}

		if nof-1 == 0 {
			if err != nil {
				t.Fatal("Failed to add tree node: ", err)
			}
		} else {
			if err == nil {
				t.Fatal("Must return an error.")
			}
			if _, ok := err.(*errors.KsiError); !ok {
				t.Fatal("Must return KSI error.")
			}
			if err.(*errors.KsiError).Code() != errors.KsiNotImplemented {
				t.Fatal("Error code mismatch.")
			}
		}
	}
}

func testTreeBuilderFailWithLevelCheckListenerNoEntries(t *testing.T, _ ...interface{}) {
	const (
		testAlgorithm     = hash.Default
		testMaxNofEntries = 2
		testTreeLevel     = 1
	)
	var (
		testListener mock.TreeBuilderListenerMock
	)

	tree, err := New(
		TreeOptRecordListener(&testListener),
		TreeOptMaxLevel(testTreeLevel),
	)
	if err != nil {
		t.Fatal("Failed to create tree builder: ", err)
	}

	for i := 0; i < testMaxNofEntries; i++ {
		if err = tree.AddNode(testAlgorithm.ZeroImprint()); err != nil {
			t.Fatal("Failed to add tree node: ", err)
		}
	}
	if len(testListener.Entries) != testMaxNofEntries {
		t.Fatal("Nof listener entries mismatch.")
	}

	// Try to add one more record. This should fail, as the tree height is at its limit.
	if err = tree.AddNode(testAlgorithm.ZeroImprint()); err == nil {
		t.Fatal("Should not be possible to create trees larger than maximum allowed size: 255.")
	}
	if len(testListener.Entries) != testMaxNofEntries {
		t.Fatal("No entries should have been added to the listener.")
	}
}

func testTreeBuilderWithMetadataAndBlindingMask(t *testing.T, _ ...interface{}) {
	tree, err := New(
		TreeOptMaskingWithPreviousLeaf([]byte{0x19, 0x45, 0x56, 0x14, 0x88, 0x78, 0x12},
			utils.StringToBin("01B0CF0A7E6E0420D27CDFA11BDFAC4AA9BC777AE4D6C0211816BCB91DE7C920AD")),
		TreeOptMaxLevel(10),
	)
	if err != nil {
		t.Fatal("Failed to create tree builder: ", err)
	}

	resource := []struct {
		h  string
		md string
	}{
		{"0109A9FE430803D8984273324CF462E40A875D483DE6DD0D86BC6DFF4D27C9D853", "user1"},
		{"01BEC84E1F95F729F4482338E781341B1615F5B0A882231AE6C0FAEF7D0E6121D5", "user2"},
		{"01C734EEFE09B6B717B0BA6997CA634ADB93E2F227BEB785BBB8B4472651084509", "user3"},
		{"01B0CF0A7E6E0420D27CDFA11BDFAC4AA9BC777AE4D6C0211816BCB91DE7C920AD", "user4"},
	}

	for _, d := range resource {
		md, err := pdu.NewMetaData(d.md)
		if err != nil {
			t.Fatal("Failed to create metadata with client ID.")
		}
		h := utils.StringToBin(d.h)
		if err = tree.AddNode(h, InputHashOptionMetadata(md), InputHashOptionUserContext(d.h)); err != nil {
			t.Fatal("Failed to add tree node: ", err)
		}
	}
	hsh, lvl, err := tree.Aggregate()
	if err != nil {
		t.Fatal("Failed to build the tree.")
	}
	if lvl != 4 {
		t.Fatal("Incorrect root hash level.")
	}
	if hsh == nil {
		t.Fatal("Root hash can not be nil.")
	}
}

func testTreeBuilderWithMetadataAndBlindingMaskNoPreviousLeaf(t *testing.T, _ ...interface{}) {
	tree, err := New(
		TreeOptMaskingWithPreviousLeaf([]byte{0x19, 0x45, 0x56, 0x14, 0x88, 0x78, 0x12},
			hash.SHA2_256.ZeroImprint()),
		TreeOptMaxLevel(10),
	)
	if err != nil {
		t.Fatal("Failed to create tree builder: ", err)
	}

	resource := []struct {
		h  string
		md string
	}{
		{"0109A9FE430803D8984273324CF462E40A875D483DE6DD0D86BC6DFF4D27C9D853", "user1"},
		{"01BEC84E1F95F729F4482338E781341B1615F5B0A882231AE6C0FAEF7D0E6121D5", "user2"},
		{"01C734EEFE09B6B717B0BA6997CA634ADB93E2F227BEB785BBB8B4472651084509", "user3"},
		{"01B0CF0A7E6E0420D27CDFA11BDFAC4AA9BC777AE4D6C0211816BCB91DE7C920AD", "user4"},
	}

	for _, d := range resource {
		md, err := pdu.NewMetaData(d.md)
		if err != nil {
			t.Fatal("Failed to create metadata with client ID.")
		}
		h := utils.StringToBin(d.h)
		err = tree.AddNode(h, InputHashOptionMetadata(md), InputHashOptionUserContext(d.h))
		if err != nil {
			t.Fatal("Failed to add tree node: ", err)
		}
	}
	hsh, lvl, err := tree.Aggregate()
	if err != nil {
		t.Fatal("Failed to build the tree.")
	}
	if lvl != 4 {
		t.Fatal("Incorrect root hash level.")
	}
	if hsh == nil {
		t.Fatal("Root hash can not be nil.")
	}
}

func testTreeBuilderWithBlindingMask(t *testing.T, _ ...interface{}) {
	tree, err := New(
		TreeOptMaskingWithPreviousLeaf([]byte{0x19, 0x45, 0x56, 0x14, 0x88, 0x78, 0x12},
			utils.StringToBin("01B0CF0A7E6E0420D27CDFA11BDFAC4AA9BC777AE4D6C0211816BCB91DE7C920AD")),
		TreeOptMaxLevel(10),
	)
	if err != nil {
		t.Fatal("Failed to create tree builder: ", err)
	}

	resource := []struct {
		h string
	}{
		{"0109A9FE430803D8984273324CF462E40A875D483DE6DD0D86BC6DFF4D27C9D853"},
		{"01BEC84E1F95F729F4482338E781341B1615F5B0A882231AE6C0FAEF7D0E6121D5"},
		{"01C734EEFE09B6B717B0BA6997CA634ADB93E2F227BEB785BBB8B4472651084509"},
		{"01B0CF0A7E6E0420D27CDFA11BDFAC4AA9BC777AE4D6C0211816BCB91DE7C920AD"},
	}

	for _, d := range resource {
		h := utils.StringToBin(d.h)
		if err = tree.AddNode(h, InputHashOptionUserContext(d.h)); err != nil {
			t.Fatal("Failed to add tree node: ", err)
		}
	}
	hsh, lvl, err := tree.Aggregate()
	if err != nil {
		t.Fatal("Failed to build the tree.")
	}
	if lvl != 3 {
		t.Fatal("Incorrect root hash level.")
	}
	if hsh == nil {
		t.Fatal("Root hash can not be nil.")
	}
}

func testTreeBuilderWithBlindingMaskNoPreviousLeaf(t *testing.T, _ ...interface{}) {
	tree, err := New(
		TreeOptMaskingWithPreviousLeaf([]byte{0x19, 0x45, 0x56, 0x14, 0x88, 0x78, 0x12},
			hash.SHA2_256.ZeroImprint()),
		TreeOptMaxLevel(10),
	)
	if err != nil {
		t.Fatal("Failed to create tree builder: ", err)
	}

	resource := []struct {
		h string
	}{
		{"0109A9FE430803D8984273324CF462E40A875D483DE6DD0D86BC6DFF4D27C9D853"},
		{"01BEC84E1F95F729F4482338E781341B1615F5B0A882231AE6C0FAEF7D0E6121D5"},
		{"01C734EEFE09B6B717B0BA6997CA634ADB93E2F227BEB785BBB8B4472651084509"},
		{"01B0CF0A7E6E0420D27CDFA11BDFAC4AA9BC777AE4D6C0211816BCB91DE7C920AD"},
	}

	for _, d := range resource {
		h := utils.StringToBin(d.h)
		if err = tree.AddNode(h, InputHashOptionUserContext(d.h)); err != nil {
			t.Fatal("Failed to add tree node: ", err)
		}
	}
	hsh, lvl, err := tree.Aggregate()
	if err != nil {
		t.Fatal("Failed to build the tree.")
	}
	if lvl != 3 {
		t.Fatal("Incorrect root hash level.")
	}
	if hsh == nil {
		t.Fatal("Root hash can not be nil.")
	}
}

func testBuildTooLargeTreeWithBlindingEnabled(t *testing.T, _ ...interface{}) {
	tree, err := New(
		TreeOptMaskingWithPreviousLeaf([]byte{0x19, 0x45, 0x56, 0x14, 0x88, 0x78, 0x12},
			utils.StringToBin("0109A9FE430803D8984273324CF462E40A875D483DE6DD0D86BC6DFF4D27C9D853")),
		TreeOptMaxLevel(3),
	)
	if err != nil {
		t.Fatal("Failed to create tree builder: ", err)
	}

	resource := []struct {
		h string
	}{
		{"0109A9FE430803D8984273324CF462E40A875D483DE6DD0D86BC6DFF4D27C9D853"},
		{"01BEC84E1F95F729F4482338E781341B1615F5B0A882231AE6C0FAEF7D0E6121D5"},
		{"01C734EEFE09B6B717B0BA6997CA634ADB93E2F227BEB785BBB8B4472651084509"},
		{"01B0CF0A7E6E0420D27CDFA11BDFAC4AA9BC777AE4D6C0211816BCB91DE7C920AD"},
	}

	for _, d := range resource {
		h := utils.StringToBin(d.h)
		if err := tree.AddNode(h, InputHashOptionUserContext(d.h)); err != nil {
			t.Fatal("Failed to add tree node: ", err)
		}
	}

	err = tree.AddNode(utils.StringToBin("01B0CF0A7E6E0420D27CDFA11BDFAC4AA9BC777AE4D6C0211816BCB91DE7C920AD"))
	if err == nil {
		t.Fatal("Should not be possible to add any other node if it would exceed the allowed tree height.")
	}
}

func testAddNodeWithTooLargeLevel(t *testing.T, _ ...interface{}) {
	tree, err := New(TreeOptMaxLevel(25))
	if err != nil {
		t.Fatal("Failed to create tree builder: ", err)
	}

	err = tree.AddNode(utils.StringToBin("0109A9FE430803D8984273324CF462E40A875D483DE6DD0D86BC6DFF4D27C9D853"),
		InputHashOptionLevel(26))
	if err == nil {
		t.Fatal("Should not be possible to add node with level which exceeds the tree's allowed height.")
	}

	err = tree.AddNode(utils.StringToBin("0109A9FE430803D8984273324CF462E40A875D483DE6DD0D86BC6DFF4D27C9D853"),
		InputHashOptionLevel(255))
	if err == nil {
		t.Fatal("Should not be possible to add node with level which exceeds the tree's allowed height.")
	}
}

func testBuildTooLargeTreeWithNodeMetadataAndLevel(t *testing.T, _ ...interface{}) {
	tree, err := New(TreeOptMaxLevel(12))
	if err != nil {
		t.Fatal("Failed to create tree builder: ", err)
	}

	resource := []struct {
		h  string
		l  byte
		md string
	}{
		{"0109A9FE430803D8984273324CF462E40A875D483DE6DD0D86BC6DFF4D27C9D853", 0, "first"},
		{"01BEC84E1F95F729F4482338E781341B1615F5B0A882231AE6C0FAEF7D0E6121D5", 8, "second"},
		{"01C734EEFE09B6B717B0BA6997CA634ADB93E2F227BEB785BBB8B4472651084509", 5, "third"},
		{"01B0CF0A7E6E0420D27CDFA11BDFAC4AA9BC777AE4D6C0211816BCB91DE7C920AD", 8, "forth"},
		{"01BB95E9B09E7F6BC95533D805739E26510A05F9788A86C7F81BA8F81E0E6C43DA", 2, "fifth"},
		{"017943B1F4521425E11B461A76B9F46B08980FFD04CD080497D55A8C063E6DCDF7", 0, "sixth"},
		{"0123C4ADE3B64A45694088FD427399D3C2EC120BB0D5DF8C5212B1562F8D821902", 6, "seventh"},
		{"01A360BBAE9A0215196449971E57EB91B6C9B39725408324BE325D40C254353FBF", 4, "eight"},
	}

	for _, d := range resource {
		meta, err := pdu.NewMetaData(d.md)
		if err != nil {
			t.Fatal("Failed to create medata from client ID.")
		}
		h := utils.StringToBin(d.h)
		if err = tree.AddNode(h, InputHashOptionLevel(d.l), InputHashOptionMetadata(meta), InputHashOptionUserContext(d.md)); err != nil {
			t.Fatal("Failed to add tree node: ", err)
		}
	}

	err = tree.AddNode(utils.StringToBin("01B0CF0A7E6E0420D27CDFA11BDFAC4AA9BC777AE4D6C0211816BCB91DE7C920AB"))
	if err == nil {
		t.Fatal("Should not be possible to create trees larger than maximum allowed size: 255.")
	}
}

func testTreeBuilderMaximumSize(t *testing.T, _ ...interface{}) {
	tree, err := New()
	if err != nil {
		t.Fatal("Failed to create tree builder: ", err)
	}

	resource := []struct {
		h string
	}{
		{"0109A9FE430803D8984273324CF462E40A875D483DE6DD0D86BC6DFF4D27C9D853"},
		{"01BEC84E1F95F729F4482338E781341B1615F5B0A882231AE6C0FAEF7D0E6121D5"},
		{"01C734EEFE09B6B717B0BA6997CA634ADB93E2F227BEB785BBB8B4472651084509"},
		{"01B0CF0A7E6E0420D27CDFA11BDFAC4AA9BC777AE4D6C0211816BCB91DE7C920AD"},
		{"01BB95E9B09E7F6BC95533D805739E26510A05F9788A86C7F81BA8F81E0E6C43DA"},
		{"017943B1F4521425E11B461A76B9F46B08980FFD04CD080497D55A8C063E6DCDF7"},
		{"0123C4ADE3B64A45694088FD427399D3C2EC120BB0D5DF8C5212B1562F8D821902"},
		{"01A360BBAE9A0215196449971E57EB91B6C9B39725408324BE325D40C254353FBF"},
	}

	for _, d := range resource {
		h := utils.StringToBin(d.h)
		if err := tree.AddNode(h, InputHashOptionLevel(252), InputHashOptionUserContext(d.h)); err != nil {
			t.Fatal("Failed to add tree node: ", err)
		}
	}

	err = tree.AddNode(utils.StringToBin("01B0CF0A7E6E0420D27CDFA11BDFAC4AA9BC777AE4D6C0211816BCB91DE7C920AB"))
	if err == nil {
		t.Fatal("Should not be possible to create trees larger than maximum allowed size: 255.")
	}
}

func testTreeBuilderMaxLevel(t *testing.T, _ ...interface{}) {

	var (
		testHsh = []byte{
			0x01, 0x09, 0xA9, 0xFE, 0x43, 0x08, 0x03, 0xD8, 0x98, 0x42, 0x73, 0x32, 0x4C, 0xF4, 0x62, 0xE4, 0x0A, 0x87, 0x5D, 0x48, 0x3D, 0xE6, 0xDD, 0x0D, 0x86, 0xBC, 0x6D, 0xFF, 0x4D, 0x27, 0xC9, 0xD8, 0x53,
		}
	)

	tree, err := New(
		TreeOptMaxLevel(2),
	)
	if err != nil {
		t.Fatal("Failed to create tree builder: ", err)
	}

	for i := 0; i < 4; i++ {
		if err := tree.AddNode(testHsh); err != nil {
			t.Fatal("Failed to add tree node: ", err)
		}
	}

	if err := tree.AddNode(testHsh); err == nil {
		t.Fatal("Tree maximum level must exceed.")
	} else {
		if errors.KsiErr(err).Code() != errors.KsiBufferOverflow {
			t.Fatal("Error code mismatch.")
		}
	}
}

func testTreeBuilderDefaultMaxLevelAddLvl255(t *testing.T, _ ...interface{}) {

	var (
		testHsh = []byte{
			0x01, 0x09, 0xA9, 0xFE, 0x43, 0x08, 0x03, 0xD8, 0x98, 0x42, 0x73, 0x32, 0x4C, 0xF4, 0x62, 0xE4, 0x0A, 0x87, 0x5D, 0x48, 0x3D, 0xE6, 0xDD, 0x0D, 0x86, 0xBC, 0x6D, 0xFF, 0x4D, 0x27, 0xC9, 0xD8, 0x53,
		}
	)

	tree, err := New()
	if err != nil {
		t.Fatal("Failed to create tree builder: ", err)
	}

	if err = tree.AddNode(testHsh, InputHashOptionLevel(0xff)); err != nil {
		t.Fatal("Failed to add tree node with level 0xff: ", err)
	}

	if err = tree.AddNode(testHsh); err == nil {
		t.Fatal("Tree maximum level must exceed.")
	} else {
		if errors.KsiErr(err).Code() != errors.KsiBufferOverflow {
			t.Fatal("Error code mismatch.")
		}
	}
}

func testTreeBuilderExceed0xffAddMeta(t *testing.T, _ ...interface{}) {

	var (
		testHsh = []byte{
			0x01, 0x09, 0xA9, 0xFE, 0x43, 0x08, 0x03, 0xD8, 0x98, 0x42, 0x73, 0x32, 0x4C, 0xF4, 0x62, 0xE4, 0x0A, 0x87, 0x5D, 0x48, 0x3D, 0xE6, 0xDD, 0x0D, 0x86, 0xBC, 0x6D, 0xFF, 0x4D, 0x27, 0xC9, 0xD8, 0x53,
		}
	)

	tree, err := New()
	if err != nil {
		t.Fatal("Failed to create tree builder: ", err)
	}

	if err := tree.AddNode(testHsh, InputHashOptionLevel(0xff), InputHashOptionMetadata(hash.Imprint(testHsh))); err == nil {
		t.Fatal("Tree maximum level must exceed.")
	} else {
		if errors.KsiErr(err).Code() != errors.KsiBufferOverflow {
			t.Fatal("Error code mismatch: ", err)
		}
	}
}

func testTreeBuilderWithMetadata(t *testing.T, _ ...interface{}) {

	var (
		testData = []struct {
			usrCtx string
			hsh    []byte
		}{
			{"Hsh1", []byte{0x01, 0x09, 0xA9, 0xFE, 0x43, 0x08, 0x03, 0xD8, 0x98, 0x42, 0x73, 0x32, 0x4C, 0xF4, 0x62, 0xE4, 0x0A, 0x87, 0x5D, 0x48, 0x3D, 0xE6, 0xDD, 0x0D, 0x86, 0xBC, 0x6D, 0xFF, 0x4D, 0x27, 0xC9, 0xD8, 0x53}},
			{"Hsh2", []byte{0x01, 0xBE, 0xC8, 0x4E, 0x1F, 0x95, 0xF7, 0x29, 0xF4, 0x48, 0x23, 0x38, 0xE7, 0x81, 0x34, 0x1B, 0x16, 0x15, 0xF5, 0xB0, 0xA8, 0x82, 0x23, 0x1A, 0xE6, 0xC0, 0xFA, 0xEF, 0x7D, 0x0E, 0x61, 0x21, 0xD5}},
			{"Hsh3", []byte{0x01, 0xC7, 0x34, 0xEE, 0xFE, 0x09, 0xB6, 0xB7, 0x17, 0xB0, 0xBA, 0x69, 0x97, 0xCA, 0x63, 0x4A, 0xDB, 0x93, 0xE2, 0xF2, 0x27, 0xBE, 0xB7, 0x85, 0xBB, 0xB8, 0xB4, 0x47, 0x26, 0x51, 0x08, 0x45, 0x09}},
			{"Hsh4", []byte{0x01, 0xB0, 0xCF, 0x0A, 0x7E, 0x6E, 0x04, 0x20, 0xD2, 0x7C, 0xDF, 0xA1, 0x1B, 0xDF, 0xAC, 0x4A, 0xA9, 0xBC, 0x77, 0x7A, 0xE4, 0xD6, 0xC0, 0x21, 0x18, 0x16, 0xBC, 0xB9, 0x1D, 0xE7, 0xC9, 0x20, 0xAD}},
		}

		testRootHsh = []byte{
			0x01, 0x60, 0x0d, 0xe2, 0x90, 0x71, 0x42, 0x08, 0xad, 0xf4, 0xaf, 0x6f, 0x7f, 0x3b, 0x02, 0xe1, 0x5f, 0xfb, 0x17, 0x6d, 0xf0, 0x14, 0xa3, 0x75, 0xd3, 0x80, 0x42, 0x11, 0x2d, 0xf5, 0xbc, 0x36, 0x3c,
		}
		testClientID = "anon"
	)

	tree, err := New()
	if err != nil {
		t.Fatal("Failed to create tree builder: ", err)
	}

	meta, err := pdu.NewMetaData(testClientID)
	if err != nil {
		t.Fatal("Failed to construct metadata: ", err)
	}

	for _, d := range testData {
		if err := tree.AddNode(d.hsh, InputHashOptionMetadata(meta), InputHashOptionUserContext(d.usrCtx)); err != nil {
			t.Fatal("Failed to add tree node: ", err)
		}
	}

	rootHsh, level, err := tree.Aggregate()
	if err != nil {
		t.Fatal("Failed to close tree: ", err)
	}
	if !hash.Equal(testRootHsh, rootHsh) {
		t.Fatal("Root hash mismatch.")
	}
	if level != 3 {
		t.Fatal("Root level mismatch.")
	}

	leafs, err := tree.Leafs()
	if err != nil {
		t.Fatal("Failed to get tree leafs: ", err)
	}
	if len(leafs) != len(testData) {
		t.Fatal("Nof tree leafs mismatch")
	}

	for _, l := range leafs {
		chain, err := l.AggregationChain()
		if err != nil {
			t.Fatal("Failed to get leaf aggregation hash chain: ", err)
		}

		chainLinks, err := chain.ChainLinks()
		if err != nil {
			t.Fatal("Failed to get aggregation hash chain links: ", err)
		}

		isLeft, err := chainLinks[0].IsLeft()
		if err != nil {
			t.Fatal("Failed to get chain link side: ", err)
		}
		if !isLeft {
			t.Fatal("Metadata is linked in the wrong side.")
		}

		metadata, err := chainLinks[0].MetaData()
		if err != nil {
			t.Fatal("Failed to get link metadata: ", err)
		}
		clientID, err := metadata.ClientID()
		if clientID != testClientID {
			t.Fatal("Metadata client ID mismatch.")
		}
	}
}

func testTreeBuilderWithImprintAsMetadata(t *testing.T, _ ...interface{}) {

	var (
		testData = [][]byte{
			{0x01, 0x09, 0xA9, 0xFE, 0x43, 0x08, 0x03, 0xD8, 0x98, 0x42, 0x73, 0x32, 0x4C, 0xF4, 0x62, 0xE4, 0x0A, 0x87, 0x5D, 0x48, 0x3D, 0xE6, 0xDD, 0x0D, 0x86, 0xBC, 0x6D, 0xFF, 0x4D, 0x27, 0xC9, 0xD8, 0x53},
			{0x01, 0xBE, 0xC8, 0x4E, 0x1F, 0x95, 0xF7, 0x29, 0xF4, 0x48, 0x23, 0x38, 0xE7, 0x81, 0x34, 0x1B, 0x16, 0x15, 0xF5, 0xB0, 0xA8, 0x82, 0x23, 0x1A, 0xE6, 0xC0, 0xFA, 0xEF, 0x7D, 0x0E, 0x61, 0x21, 0xD5},

			{0x01, 0xC7, 0x34, 0xEE, 0xFE, 0x09, 0xB6, 0xB7, 0x17, 0xB0, 0xBA, 0x69, 0x97, 0xCA, 0x63, 0x4A, 0xDB, 0x93, 0xE2, 0xF2, 0x27, 0xBE, 0xB7, 0x85, 0xBB, 0xB8, 0xB4, 0x47, 0x26, 0x51, 0x08, 0x45, 0x09},
			{0x01, 0xB0, 0xCF, 0x0A, 0x7E, 0x6E, 0x04, 0x20, 0xD2, 0x7C, 0xDF, 0xA1, 0x1B, 0xDF, 0xAC, 0x4A, 0xA9, 0xBC, 0x77, 0x7A, 0xE4, 0xD6, 0xC0, 0x21, 0x18, 0x16, 0xBC, 0xB9, 0x1D, 0xE7, 0xC9, 0x20, 0xAD},
		}
		testRootHsh = []byte{
			0x01, 0x64, 0x59, 0x7a, 0x59, 0x84, 0xe8, 0x68, 0x2b, 0x5d, 0x6e, 0x3b, 0x15, 0xdd, 0x73, 0x1d, 0xdf, 0xeb, 0x8e, 0x72, 0x8e, 0x60, 0x8b, 0x6b, 0x1f, 0xc9, 0x1a, 0x1f, 0x01, 0x46, 0x7a, 0xa2, 0xc4,
		}
	)

	tree, err := New()
	if err != nil {
		t.Fatal("Failed to create tree builder: ", err)
	}

	for i := 0; i < len(testData); i++ {
		if i%2 == 0 {
			if err := tree.AddNode(testData[i], InputHashOptionMetadata(hash.Imprint(testData[i+1]))); err != nil {
				t.Fatal("Failed to add tree node: ", err)
			}
		}
	}

	rootHsh, level, err := tree.Aggregate()
	if err != nil {
		t.Fatal("Failed to close tree: ", err)
	}
	if !hash.Equal(testRootHsh, rootHsh) {
		t.Fatal("Root hash mismatch.")
	}
	if level != 2 {
		t.Fatal("Root level mismatch.")
	}

	leafs, err := tree.Leafs()
	if err != nil {
		t.Fatal("Failed to get tree leafs: ", err)
	}
	if len(leafs) != len(testData)/2 {
		t.Fatal("Nof tree leafs mismatch")
	}
}

func testTreeBuilderWithUnsupportedMetadata(t *testing.T, _ ...interface{}) {
	tree, err := New()
	if err != nil {
		t.Fatal("Failed to create tree builder: ", err)
	}
	if err := tree.AddNode(hash.SHA2_256.ZeroImprint(), InputHashOptionMetadata(tree)); err == nil {
		t.Fatal("Must fail with unsupported metadata type.")
	}
}

func testTreeBuilderMaskingWithPrevRecFirstBlock(t *testing.T, _ ...interface{}) {

	var (
		testRoot     = utils.StringToBin("01f6c52045de5f79b87651312284114cd76536009f30126af5ed53fab4652e2b86")
		testHash     = utils.StringToBin("01004313f53502a18fe4a31ae0197ab09d4597042942a3a54e846fa01ff5479fa2")
		testIV       = []byte{0x01, 0x02, 0xff, 0xfe, 0xaa, 0xa9, 0xf1, 0x55, 0x23, 0x51, 0xa1}
		testRecCount = 101
	)

	tree, err := New(
		TreeOptMaskingWithPreviousLeaf(testIV, hash.Default.ZeroImprint()),
	)
	if err != nil {
		t.Fatal("Failed to create block signer: ", err)
	}

	for i := 0; i < testRecCount; i++ {
		if err := tree.AddNode(testHash); err != nil {
			t.Fatal("Failed to add leaf to block: ", err)
		}
	}

	rootHsh, _, err := tree.Aggregate()
	if err != nil {
		t.Fatal("Failed to close tree: ", err)
	}

	if !hash.Equal(rootHsh, testRoot) {
		t.Fatal("Tree root hash mismatch.")
	}

	leafs, err := tree.Leafs()
	if err != nil {
		t.Fatal("Failed to get tree leafs: ", err)
	}
	if len(leafs) != testRecCount {
		t.Fatal("Nof tree leafs mismatch")
	}
}

func testTreeBuilderMaskingWithPrevRecAndMetaAsImprint(t *testing.T, _ ...interface{}) {

	var (
		testData = [][]byte{
			{0x01,
				0x09, 0xA9, 0xFE, 0x43, 0x08, 0x03, 0xD8, 0x98, 0x42, 0x73, 0x32, 0x4C, 0xF4, 0x62, 0xE4, 0x0A,
				0x87, 0x5D, 0x48, 0x3D, 0xE6, 0xDD, 0x0D, 0x86, 0xBC, 0x6D, 0xFF, 0x4D, 0x27, 0xC9, 0xD8, 0x53},
			{0x01,
				0xBE, 0xC8, 0x4E, 0x1F, 0x95, 0xF7, 0x29, 0xF4, 0x48, 0x23, 0x38, 0xE7, 0x81, 0x34, 0x1B, 0x16,
				0x15, 0xF5, 0xB0, 0xA8, 0x82, 0x23, 0x1A, 0xE6, 0xC0, 0xFA, 0xEF, 0x7D, 0x0E, 0x61, 0x21, 0xD5},

			{0x01,
				0xC7, 0x34, 0xEE, 0xFE, 0x09, 0xB6, 0xB7, 0x17, 0xB0, 0xBA, 0x69, 0x97, 0xCA, 0x63, 0x4A, 0xDB,
				0x93, 0xE2, 0xF2, 0x27, 0xBE, 0xB7, 0x85, 0xBB, 0xB8, 0xB4, 0x47, 0x26, 0x51, 0x08, 0x45, 0x09},
			{0x01,
				0xB0, 0xCF, 0x0A, 0x7E, 0x6E, 0x04, 0x20, 0xD2, 0x7C, 0xDF, 0xA1, 0x1B, 0xDF, 0xAC, 0x4A, 0xA9,
				0xBC, 0x77, 0x7A, 0xE4, 0xD6, 0xC0, 0x21, 0x18, 0x16, 0xBC, 0xB9, 0x1D, 0xE7, 0xC9, 0x20, 0xAD},
		}
		testRootHsh = []byte{0x01,
			0x99, 0x2d, 0x8d, 0xfd, 0x11, 0x38, 0x14, 0x01, 0xe8, 0xf1, 0x91, 0xb6, 0x75, 0x64, 0x32, 0x16,
			0x46, 0x9e, 0xd9, 0x29, 0x17, 0x9d, 0x9f, 0xbb, 0x76, 0x8f, 0xe1, 0x5f, 0xc0, 0xea, 0xaf, 0xf4}
		testIV = []byte{0x01, 0x02, 0xff, 0xfe, 0xaa, 0xa9, 0xf1, 0x55, 0x23, 0x51, 0xa1}
	)

	tree, err := New(
		TreeOptMaskingWithPreviousLeaf(testIV, hash.Default.ZeroImprint()),
	)
	if err != nil {
		t.Fatal("Failed to create tree builder: ", err)
	}

	for i := 0; i < len(testData); i++ {
		if i%2 == 0 {
			if err := tree.AddNode(testData[i], InputHashOptionMetadata(hash.Imprint(testData[i+1]))); err != nil {
				t.Fatal("Failed to add tree node: ", err)
			}
		}
	}

	rootHsh, level, err := tree.Aggregate()
	if err != nil {
		t.Fatal("Failed to close tree: ", err)
	}
	if !hash.Equal(testRootHsh, rootHsh) {
		t.Fatal("Root hash mismatch.")
	}
	if level != 2+1 {
		t.Fatal("Root level mismatch.")
	}
	leafs, err := tree.Leafs()
	if err != nil {
		t.Fatal("Failed to get tree leafs: ", err)
	}
	if len(leafs) != len(testData)/2 {
		t.Fatal("Nof tree leafs mismatch")
	}
}

func testTreeBuilderNoMaskingVerifyInputExposed(t *testing.T, _ ...interface{}) {

	var (
		testRecordHsh = [][]byte{
			{0x01,
				0x09, 0xA9, 0xFE, 0x43, 0x08, 0x03, 0xD8, 0x98, 0x42, 0x73, 0x32, 0x4C, 0xF4, 0x62, 0xE4, 0x0A,
				0x87, 0x5D, 0x48, 0x3D, 0xE6, 0xDD, 0x0D, 0x86, 0xBC, 0x6D, 0xFF, 0x4D, 0x27, 0xC9, 0xD8, 0x53},
			{0x01,
				0xC7, 0x34, 0xEE, 0xFE, 0x09, 0xB6, 0xB7, 0x17, 0xB0, 0xBA, 0x69, 0x97, 0xCA, 0x63, 0x4A, 0xDB,
				0x93, 0xE2, 0xF2, 0x27, 0xBE, 0xB7, 0x85, 0xBB, 0xB8, 0xB4, 0x47, 0x26, 0x51, 0x08, 0x45, 0x09},
		}
	)

	tree, err := New()
	if err != nil {
		t.Fatal("Failed to create tree builder: ", err)
	}

	for _, h := range testRecordHsh {
		if err := tree.AddNode(h); err != nil {
			t.Fatal("Failed to add tree node: ", err)
		}
	}

	if _, _, err := tree.Aggregate(); err != nil {
		t.Fatal("Failed to close tree: ", err)
	}
	leafs, err := tree.Leafs()
	if err != nil {
		t.Fatal("Failed to get tree leafs: ", err)
	}

	for leafIdx, leaf := range leafs {
		chain, err := leaf.AggregationChain()
		if err != nil {
			t.Fatal("Failed to get leaf aggr chain: ", err)
		}

		chainInputHsh, err := chain.InputHash()
		if err != nil {
			t.Fatal("Failed to get aggr chain input hash: ", err)
		}
		if !hash.Equal(chainInputHsh, testRecordHsh[leafIdx]) {
			t.Fatal("Aggr chain input hash mismatch.")
		}

		links, err := chain.ChainLinks()
		for _, l := range links {
			sibling, err := l.SiblingHash()
			if err != nil {
				t.Fatal("Failed to get aggr chain link sibling: ", err)
			}
			if sibling == nil {
				t.Fatal("Sibling must contain an imprint.")
			}

			for i, r := range testRecordHsh {
				if i != leafIdx {
					if !hash.Equal(r, sibling) {
						t.Fatal("Input hash from sibling record is exposed.")
					}
				}
			}
		}
	}
}

func testTreeBuilderMaskingVerifyInputNotExposed(t *testing.T, _ ...interface{}) {
	testTreeBuilderMaskingVerifyInputNotExposedGeneral(t, "prevLeaf")
}

func testTreeBuilderMaskingVerifyInputNotExposedWithIndexMasking(t *testing.T, _ ...interface{}) {
	testTreeBuilderMaskingVerifyInputNotExposedGeneral(t, "index")
}

func testTreeBuilderMaskingVerifyInputNotExposedGeneral(t *testing.T, maskingType string) {

	var (
		tree          *Tree
		err           error
		testRecordHsh = [][]byte{
			{0x01,
				0x09, 0xA9, 0xFE, 0x43, 0x08, 0x03, 0xD8, 0x98, 0x42, 0x73, 0x32, 0x4C, 0xF4, 0x62, 0xE4, 0x0A,
				0x87, 0x5D, 0x48, 0x3D, 0xE6, 0xDD, 0x0D, 0x86, 0xBC, 0x6D, 0xFF, 0x4D, 0x27, 0xC9, 0xD8, 0x53},
			{0x01,
				0xC7, 0x34, 0xEE, 0xFE, 0x09, 0xB6, 0xB7, 0x17, 0xB0, 0xBA, 0x69, 0x97, 0xCA, 0x63, 0x4A, 0xDB,
				0x93, 0xE2, 0xF2, 0x27, 0xBE, 0xB7, 0x85, 0xBB, 0xB8, 0xB4, 0x47, 0x26, 0x51, 0x08, 0x45, 0x09},
		}
		testIV = []byte{0x01, 0x02, 0xff, 0xfe, 0xaa, 0xa9, 0xf1, 0x55, 0x23, 0x51, 0xa1}
	)

	switch maskingType {
	case "prevLeaf":
		tree, err = New(
			TreeOptMaskingWithPreviousLeaf(testIV, hash.Default.ZeroImprint()),
		)
	case "index":
		tree, err = New(
			TreeOptMaskingWithIndex(testIV),
		)
	}
	if err != nil {
		t.Fatal("Failed to create tree builder: ", err)
	}

	for _, h := range testRecordHsh {
		if err := tree.AddNode(h); err != nil {
			t.Fatal("Failed to add tree node: ", err)
		}
	}

	if _, _, err := tree.Aggregate(); err != nil {
		t.Fatal("Failed to close tree: ", err)
	}
	leafs, err := tree.Leafs()
	if err != nil {
		t.Fatal("Failed to get tree leafs: ", err)
	}

	for leafIdx, leaf := range leafs {
		chain, err := leaf.AggregationChain()
		if err != nil {
			t.Fatal("Failed to get leaf aggr chain: ", err)
		}

		chainInputHsh, err := chain.InputHash()
		if err != nil {
			t.Fatal("Failed to get aggr chain input hash: ", err)
		}
		if !hash.Equal(chainInputHsh, testRecordHsh[leafIdx]) {
			t.Fatal("Aggr chain input hash mismatch.")
		}

		links, err := chain.ChainLinks()
		for _, l := range links {
			sibling, err := l.SiblingHash()
			if err != nil {
				t.Fatal("Failed to get aggr chain link sibling: ", err)
			}
			if sibling == nil {
				t.Fatal("Sibling must contain an imprint.")
			}

			for i, r := range testRecordHsh {
				if i != leafIdx {
					if hash.Equal(r, sibling) {
						t.Fatal("Input hash from sibling record is exposed.")
					}
				}
			}
		}
	}
}

func testTreeBuilderNoMaskingMetaAsImprintVerifyRootExposed(t *testing.T, _ ...interface{}) {

	var (
		testRecordHsh = []hash.Imprint{
			{0x01,
				0x09, 0xA9, 0xFE, 0x43, 0x08, 0x03, 0xD8, 0x98, 0x42, 0x73, 0x32, 0x4C, 0xF4, 0x62, 0xE4, 0x0A,
				0x87, 0x5D, 0x48, 0x3D, 0xE6, 0xDD, 0x0D, 0x86, 0xBC, 0x6D, 0xFF, 0x4D, 0x27, 0xC9, 0xD8, 0x53},
			{0x01,
				0xC7, 0x34, 0xEE, 0xFE, 0x09, 0xB6, 0xB7, 0x17, 0xB0, 0xBA, 0x69, 0x97, 0xCA, 0x63, 0x4A, 0xDB,
				0x93, 0xE2, 0xF2, 0x27, 0xBE, 0xB7, 0x85, 0xBB, 0xB8, 0xB4, 0x47, 0x26, 0x51, 0x08, 0x45, 0x09},
		}
		testMetaHsh = []hash.Imprint{
			{0x01,
				0xBE, 0xC8, 0x4E, 0x1F, 0x95, 0xF7, 0x29, 0xF4, 0x48, 0x23, 0x38, 0xE7, 0x81, 0x34, 0x1B, 0x16,
				0x15, 0xF5, 0xB0, 0xA8, 0x82, 0x23, 0x1A, 0xE6, 0xC0, 0xFA, 0xEF, 0x7D, 0x0E, 0x61, 0x21, 0xD5},
			{0x01,
				0xB0, 0xCF, 0x0A, 0x7E, 0x6E, 0x04, 0x20, 0xD2, 0x7C, 0xDF, 0xA1, 0x1B, 0xDF, 0xAC, 0x4A, 0xA9,
				0xBC, 0x77, 0x7A, 0xE4, 0xD6, 0xC0, 0x21, 0x18, 0x16, 0xBC, 0xB9, 0x1D, 0xE7, 0xC9, 0x20, 0xAD},
		}

		recMetaRoot = make([]hash.Imprint, len(testRecordHsh))
	)

	tree, err := New()
	if err != nil {
		t.Fatal("Failed to create tree builder: ", err)
	}

	for i, h := range testRecordHsh {
		if err := tree.AddNode(h, InputHashOptionMetadata(testMetaHsh[i])); err != nil {
			t.Fatal("Failed to add tree node: ", err)
		}

		iTree, err := New()
		if err != nil {
			t.Fatal("Failed to create tree builder: ", err)
		}

		if err := iTree.AddNode(h, InputHashOptionMetadata(testMetaHsh[i])); err != nil {
			t.Fatal("Failed to add tree node: ", err)
		}
		iRoot, _, err := iTree.Aggregate()
		if err != nil {
			t.Fatal("Failed to close tree: ", err)
		}
		recMetaRoot[i] = iRoot
	}

	if _, _, err := tree.Aggregate(); err != nil {
		t.Fatal("Failed to close tree: ", err)
	}
	leafs, err := tree.Leafs()
	if err != nil {
		t.Fatal("Failed to get tree leafs: ", err)
	}

	verifier := func(chainIdx int, exposeHsh hash.Imprint) bool {
		chain, err := leafs[chainIdx].AggregationChain()
		if err != nil {
			t.Fatal("Failed to get leaf aggr chain: ", err)
		}

		chainInputHsh, err := chain.InputHash()
		if err != nil {
			t.Fatal("Failed to get aggr chain input hash: ", err)
		}
		if !hash.Equal(chainInputHsh, testRecordHsh[chainIdx]) {
			t.Fatal("Aggr chain input hash mismatch.")
		}

		found := false
		links, err := chain.ChainLinks()
		for _, l := range links {
			sibling, err := l.SiblingHash()
			if err != nil {
				t.Fatal("Failed to get aggr chain link sibling: ", err)
			}
			if sibling == nil {
				t.Fatal("Sibling must contain an imprint.")
			}

			if hash.Equal(exposeHsh, sibling) {
				found = true
			}
		}
		return found
	}

	if !verifier(0, recMetaRoot[1]) {
		t.Fatal("Record-metadata root from sibling record is not exposed.")
	}
	if !verifier(1, recMetaRoot[0]) {
		t.Fatal("Record-metadata root from sibling record is not exposed.")
	}
}

func testTreeBuilderMaskingWithPrevRecAndMetaAsImprintVerifyInputNotExposed(t *testing.T, _ ...interface{}) {

	var (
		testRecordHsh = []hash.Imprint{
			{0x01,
				0x09, 0xA9, 0xFE, 0x43, 0x08, 0x03, 0xD8, 0x98, 0x42, 0x73, 0x32, 0x4C, 0xF4, 0x62, 0xE4, 0x0A,
				0x87, 0x5D, 0x48, 0x3D, 0xE6, 0xDD, 0x0D, 0x86, 0xBC, 0x6D, 0xFF, 0x4D, 0x27, 0xC9, 0xD8, 0x53},
			{0x01,
				0xC7, 0x34, 0xEE, 0xFE, 0x09, 0xB6, 0xB7, 0x17, 0xB0, 0xBA, 0x69, 0x97, 0xCA, 0x63, 0x4A, 0xDB,
				0x93, 0xE2, 0xF2, 0x27, 0xBE, 0xB7, 0x85, 0xBB, 0xB8, 0xB4, 0x47, 0x26, 0x51, 0x08, 0x45, 0x09},
		}
		testMetaHsh = []hash.Imprint{
			{0x01,
				0xBE, 0xC8, 0x4E, 0x1F, 0x95, 0xF7, 0x29, 0xF4, 0x48, 0x23, 0x38, 0xE7, 0x81, 0x34, 0x1B, 0x16,
				0x15, 0xF5, 0xB0, 0xA8, 0x82, 0x23, 0x1A, 0xE6, 0xC0, 0xFA, 0xEF, 0x7D, 0x0E, 0x61, 0x21, 0xD5},
			{0x01,
				0xB0, 0xCF, 0x0A, 0x7E, 0x6E, 0x04, 0x20, 0xD2, 0x7C, 0xDF, 0xA1, 0x1B, 0xDF, 0xAC, 0x4A, 0xA9,
				0xBC, 0x77, 0x7A, 0xE4, 0xD6, 0xC0, 0x21, 0x18, 0x16, 0xBC, 0xB9, 0x1D, 0xE7, 0xC9, 0x20, 0xAD},
		}
		testIV = []byte{0x01, 0x02, 0xff, 0xfe, 0xaa, 0xa9, 0xf1, 0x55, 0x23, 0x51, 0xa1}

		recMetaRoot = make([]hash.Imprint, len(testRecordHsh))
	)

	tree, err := New(
		TreeOptMaskingWithPreviousLeaf(testIV, hash.Default.ZeroImprint()),
	)
	if err != nil {
		t.Fatal("Failed to create tree builder: ", err)
	}

	for i, h := range testRecordHsh {
		if err := tree.AddNode(h, InputHashOptionMetadata(testMetaHsh[i])); err != nil {
			t.Fatal("Failed to add tree node: ", err)
		}

		iTree, err := New()
		if err != nil {
			t.Fatal("Failed to create tree builder: ", err)
		}

		if err := iTree.AddNode(h, InputHashOptionMetadata(testMetaHsh[i])); err != nil {
			t.Fatal("Failed to add tree node: ", err)
		}
		iRoot, _, err := iTree.Aggregate()
		if err != nil {
			t.Fatal("Failed to close tree: ", err)
		}
		recMetaRoot[i] = iRoot
	}

	if _, _, err = tree.Aggregate(); err != nil {
		t.Fatal("Failed to close tree: ", err)
	}
	leafs, err := tree.Leafs()
	if err != nil {
		t.Fatal("Failed to get tree leafs: ", err)
	}

	verifier := func(chainIdx int, exposeHsh hash.Imprint) bool {
		chain, err := leafs[chainIdx].AggregationChain()
		if err != nil {
			t.Fatal("Failed to get leaf aggr chain: ", err)
		}

		chainInputHsh, err := chain.InputHash()
		if err != nil {
			t.Fatal("Failed to get aggr chain input hash: ", err)
		}
		if !hash.Equal(chainInputHsh, testRecordHsh[chainIdx]) {
			t.Fatal("Aggr chain input hash mismatch.")
		}

		found := false
		links, err := chain.ChainLinks()
		for _, l := range links {
			sibling, err := l.SiblingHash()
			if err != nil {
				t.Fatal("Failed to get aggr chain link sibling: ", err)
			}
			if sibling == nil {
				t.Fatal("Sibling must contain an imprint.")
			}

			if hash.Equal(exposeHsh, sibling) {
				found = true
			}
		}
		return found
	}

	if verifier(0, recMetaRoot[1]) {
		t.Fatal("Record-metadata root from sibling record is exposed.")
	}
	if verifier(1, recMetaRoot[0]) {
		t.Fatal("Record-metadata root from sibling record is exposed.")
	}

}

func testTreeBuilderMaskingMetaAsImprintUneven(t *testing.T, _ ...interface{}) {

	var (
		testRecordHsh = [][]byte{
			{0x01,
				0x09, 0xA9, 0xFE, 0x43, 0x08, 0x03, 0xD8, 0x98, 0x42, 0x73, 0x32, 0x4C, 0xF4, 0x62, 0xE4, 0x0A,
				0x87, 0x5D, 0x48, 0x3D, 0xE6, 0xDD, 0x0D, 0x86, 0xBC, 0x6D, 0xFF, 0x4D, 0x27, 0xC9, 0xD8, 0x53},
			{0x01,
				0xC7, 0x34, 0xEE, 0xFE, 0x09, 0xB6, 0xB7, 0x17, 0xB0, 0xBA, 0x69, 0x97, 0xCA, 0x63, 0x4A, 0xDB,
				0x93, 0xE2, 0xF2, 0x27, 0xBE, 0xB7, 0x85, 0xBB, 0xB8, 0xB4, 0x47, 0x26, 0x51, 0x08, 0x45, 0x09},
			{0x01,
				0x99, 0x2d, 0x8d, 0xfd, 0x11, 0x38, 0x14, 0x01, 0xe8, 0xf1, 0x91, 0xb6, 0x75, 0x64, 0x32, 0x16,
				0x46, 0x9e, 0xd9, 0x29, 0x17, 0x9d, 0x9f, 0xbb, 0x76, 0x8f, 0xe1, 0x5f, 0xc0, 0xea, 0xaf, 0xff},
		}
		testMetaHsh = [][]byte{
			{0x01,
				0xBE, 0xC8, 0x4E, 0x1F, 0x95, 0xF7, 0x29, 0xF4, 0x48, 0x23, 0x38, 0xE7, 0x81, 0x34, 0x1B, 0x16,
				0x15, 0xF5, 0xB0, 0xA8, 0x82, 0x23, 0x1A, 0xE6, 0xC0, 0xFA, 0xEF, 0x7D, 0x0E, 0x61, 0x21, 0xD5},
			{0x01,
				0xB0, 0xCF, 0x0A, 0x7E, 0x6E, 0x04, 0x20, 0xD2, 0x7C, 0xDF, 0xA1, 0x1B, 0xDF, 0xAC, 0x4A, 0xA9,
				0xBC, 0x77, 0x7A, 0xE4, 0xD6, 0xC0, 0x21, 0x18, 0x16, 0xBC, 0xB9, 0x1D, 0xE7, 0xC9, 0x20, 0xAD},
			nil,
		}
		testIV = []byte{0x01, 0x02, 0xff, 0xfe, 0xaa, 0xa9, 0xf1, 0x55, 0x23, 0x51, 0xa1}
	)

	tree, err := New(
		TreeOptMaskingWithPreviousLeaf(testIV, hash.Default.ZeroImprint()),
	)
	if err != nil {
		t.Fatal("Failed to create tree builder: ", err)
	}

	for i, h := range testRecordHsh {
		if err := tree.AddNode(h, InputHashOptionMetadata(hash.Imprint(testMetaHsh[i]))); err != nil {
			t.Fatal("Failed to add tree node: ", err)
		}
	}

	treeRootHsh, treeRootLvl, err := tree.Aggregate()
	if err != nil {
		t.Fatal("Failed to close tree: ", err)
	}
	leafs, err := tree.Leafs()
	if err != nil {
		t.Fatal("Failed to get tree leafs: ", err)
	}

	for _, leaf := range leafs {
		chain, err := leaf.AggregationChain()
		if err != nil {
			t.Fatal("Failed to get leaf aggr chain: ", err)
		}

		chainRootHsh, chainRootLvl, err := chain.Aggregate(0)
		if err != nil {
			t.Fatal("Failed to aggregate chain: ", err)
		}
		if treeRootLvl != chainRootLvl {
			t.Fatal("Chain root level mismatch.")
		}
		if !hash.Equal(treeRootHsh, chainRootHsh) {
			t.Fatal("Chain root hash mismatch.")
		}
	}
}
